
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OwnYourPrime Meal Tracker</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg-dark: #08090f;
      --surface: #141724;
      --surface-soft: #1c1f30;
      --surface-alt: #23273b;
      --surface-highlight: #2f3452;
      --text-strong: #f5f7fb;
      --text-muted: #9aa0ba;
      --accent: #15c5a3;
      --accent-soft: rgba(21, 197, 163, 0.15);
      --danger: #f75f78;
      --warning: #ffb347;
      --success: #5cd7b8;
      --radius: 16px;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(circle at top, rgba(33, 39, 61, 0.45), rgba(8, 9, 15, 0.9)), var(--bg-dark);
      color: var(--text-strong);
      min-height: 100vh;
    }

    header {
      display: flex;
      flex-direction: column;
      background: linear-gradient(120deg, rgba(27, 32, 51, 0.95), rgba(16, 19, 32, 0.95));
      backdrop-filter: blur(18px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      padding: 24px 40px 20px;
      box-shadow: var(--shadow);
      position: sticky;
      top: 0;
      z-index: 20;
    }

    header .top-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    header h1 {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 1.8rem;
      letter-spacing: 0.5px;
      margin: 0;
    }

    header h1 i {
      color: var(--accent);
      text-shadow: 0 0 16px rgba(21, 197, 163, 0.6);
    }

    header .tagline {
      margin-top: 6px;
      font-size: 0.95rem;
      color: var(--text-muted);
    }

    nav {
      display: flex;
      gap: 10px;
      margin-top: 18px;
    }

    nav button {
      border: none;
      background: var(--surface);
      color: var(--text-muted);
      padding: 10px 16px;
      border-radius: 999px;
      font-weight: 600;
      letter-spacing: 0.4px;
      cursor: pointer;
      transition: 0.25s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    nav button.active {
      background: var(--accent);
      color: #081014;
      box-shadow: 0 6px 14px rgba(21, 197, 163, 0.35);
    }

    nav button:hover:not(.active) {
      background: var(--surface-alt);
      color: var(--text-strong);
    }

    .goal-type-hint {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
      min-height: 1.2em;
    }

    .goal-type-hint.warning {
      color: var(--warning);
    }

    .goal-type-hint.success {
      color: var(--success);
    }

    main {
      padding: 30px 40px 60px;
      display: flex;
      flex-direction: column;
      gap: 30px;
    }

    .page {
      display: none;
      animation: fadeIn 0.35s ease;
    }

    .page.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .overview-grid {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 24px;
    }

    .card {
      background: linear-gradient(160deg, rgba(30, 34, 51, 0.92), rgba(20, 23, 36, 0.92));
      border-radius: var(--radius);
      padding: 22px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .card h2 {
      margin: 0;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card h2 i {
      color: var(--accent);
    }

    .card > h2 {
      margin-bottom: 18px;
    }

    .card-header-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 18px;
      flex-wrap: wrap;
    }

    .card-header-controls h2 {
      margin: 0;
    }

    .ghost-button {
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: transparent;
      color: var(--text-muted);
      padding: 6px 14px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }

    .ghost-button:hover,
    .ghost-button:focus {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-strong);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .ghost-button:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(21, 197, 163, 0.35);
    }

    .macro-section.collapsed {
      display: none;
    }

    .summary-stack {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #summaryCards {
      margin-top: 12px;
    }

    .summary-banner {
      display: none;
      margin: 0 40px;
      padding: 14px 20px;
      border-radius: 16px;
      font-weight: 600;
      letter-spacing: 0.4px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .summary-banner.show {
      display: block;
      animation: popIn 0.4s ease;
    }

    .summary-banner.celebration {
      background: linear-gradient(120deg, rgba(92, 215, 184, 0.2), rgba(92, 215, 184, 0.4));
      color: #c8fff1;
    }

    .summary-banner.warning {
      background: linear-gradient(120deg, rgba(247, 95, 120, 0.2), rgba(247, 95, 120, 0.35));
      color: #ffd2db;
    }

    @keyframes popIn {
      from { opacity: 0; transform: translateY(-10px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }

    .summary-card {
      background: linear-gradient(140deg, var(--surface), var(--surface-soft));
      border-radius: 14px;
      padding: 18px;
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 12px;
      align-items: center;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    .summary-card::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(21, 197, 163, 0.18), transparent 60%);
      opacity: 0.6;
      pointer-events: none;
    }

    .summary-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--accent-soft);
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
    }

    .summary-details {
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 2;
    }

    .summary-details .value {
      font-size: 1.35rem;
      font-weight: 600;
      letter-spacing: 0.4px;
    }

    .summary-details .label {
      font-size: 0.85rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .progress-track {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, rgba(21, 197, 163, 0.9), rgba(48, 220, 188, 0.6));
      border-radius: 999px;
    }

    .water-block {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .water-actions {
      display: flex;
      gap: 10px;
    }

    .water-actions input {
      flex: 1;
    }

    label {
      display: block;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    input[type="text"],
    input[type="number"],
    input[type="date"],
    input[type="time"],
    select,
    textarea {
      width: 100%;
      padding: 11px 14px;
      background: var(--surface-alt);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      color: var(--text-strong);
      font-size: 0.95rem;
      transition: border-color 0.2s ease;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: rgba(21, 197, 163, 0.6);
      box-shadow: 0 0 0 3px rgba(21, 197, 163, 0.15);
    }

    textarea {
      resize: vertical;
      min-height: 80px;
    }

    .ingredients-area {
      min-height: 140px;
    }

    button.primary {
      background: linear-gradient(120deg, rgba(21, 197, 163, 0.95), rgba(25, 180, 226, 0.9));
      color: #04141a;
      border: none;
      border-radius: 999px;
      padding: 12px 20px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 12px 25px rgba(21, 197, 163, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button.primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 30px rgba(21, 197, 163, 0.4);
    }

    button.secondary,
    .chip {
      background: var(--surface-alt);
      color: var(--text-strong);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      padding: 10px 16px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    button.secondary:hover,
    .chip:hover {
      background: var(--surface-highlight);
      transform: translateY(-1px);
    }

    .quick-presets {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 18px;
    }

    .meal-type-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 16px;
    }

    .meal-type-options button {
      flex: 1 1 120px;
      justify-content: center;
    }

    .meal-type-options button.active {
      background: var(--accent);
      color: #081014;
      box-shadow: 0 12px 24px rgba(21, 197, 163, 0.35);
    }

    .quick-presets button {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      text-align: left;
    }

    .preset-name {
      font-weight: 600;
    }

    .preset-cal {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .preset-time {
      font-size: 0.75rem;
      color: var(--warning);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
      font-size: 0.92rem;
    }

    th, td {
      text-align: left;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    th {
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.6px;
      color: var(--text-muted);
      background: rgba(255, 255, 255, 0.02);
    }

    tbody tr:hover {
      background: rgba(255, 255, 255, 0.02);
    }

    .analytics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
    }

    .analytics-hero {
      display: flex;
      flex-direction: column;
      gap: 18px;
      margin-bottom: 24px;
    }

    .analytics-hero-header p {
      margin: 6px 0 0;
      color: var(--text-muted);
      max-width: 540px;
      line-height: 1.5;
    }

    .analytics-stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 14px;
    }

    .stat-card {
      background: var(--surface-alt);
      border-radius: 14px;
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--text-muted);
    }

    .stat-value {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--text-strong);
    }

    .stat-note {
      font-size: 0.85rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .analytics-card {
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      cursor: pointer;
      background: var(--surface-alt);
      border-radius: 18px;
      padding: 20px;
    }

    .analytics-card.weight-projection-card {
      grid-column: 1 / -1;
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 24px;
    }

    .analytics-card.weight-projection-card .chart-note {
      margin-top: 0;
      color: var(--text-muted);
    }

    .weight-projection-chart {
      position: relative;
      border-radius: calc(var(--radius) - 6px);
      background: linear-gradient(160deg, rgba(32, 36, 54, 0.65), rgba(18, 21, 34, 0.8));
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 18px 18px 12px;
      min-height: 260px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .weight-projection-chart canvas {
      width: 100%;
    }

    .weight-chart-empty {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 0 32px;
      color: var(--text-muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .weight-chart-empty.hidden {
      display: none;
    }

    .timeline-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.55px;
      color: var(--text-muted);
    }

    .timeline-value {
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--text-strong);
      letter-spacing: 0.2px;
    }

    .timeline-item--inactive .timeline-value {
      color: rgba(255, 255, 255, 0.6);
    }

    .timeline-period {
      font-size: 0.9rem;
      color: var(--text-muted);
      min-height: 1.4em;
      line-height: 1.4;
    }

    .timeline-empty {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.95rem;
      padding: 16px;
    }

    @media (max-width: 1024px) {
      .analytics-card.weight-projection-card {
        padding: 20px;
      }

      .weight-projection-chart {
        min-height: 220px;
        padding: 16px;
      }

      .weight-chart-empty {
        padding: 0 24px;
      }
    }

    .analytics-card:hover,
    .analytics-card:focus-visible {
      transform: translateY(-4px);
      box-shadow: 0 18px 30px rgba(0, 0, 0, 0.35);
      border-color: rgba(21, 197, 163, 0.4);
      outline: none;
    }

    .analytics-card-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
    }

    .analytics-card-header h3 {
      margin: 0;
      font-size: 1.05rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
      letter-spacing: 0.2px;
    }

    .analytics-card-subtitle {
      margin: 4px 0 0;
      font-size: 0.82rem;
      color: rgba(217, 222, 255, 0.72);
      letter-spacing: 0.3px;
    }

    .chart-hint {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: var(--text-muted);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
    }

    .analytics-card canvas {
      width: 100%;
    }

    .analytics-card .chart-note {
      margin-top: 10px;
      font-size: 0.8rem;
    }

    .chart-note {
      margin-top: 12px;
      font-size: 0.85rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .meal-meta-row {
      grid-template-columns: minmax(0, 1fr) 180px;
      align-items: end;
      gap: 16px;
    }

    .meal-meta-row .time-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      justify-self: start;
      max-width: 180px;
      width: 100%;
    }

    .calorie-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-width: 100%;
    }

    .calorie-input-row {
      display: flex;
      align-items: center;
      gap: 14px;
      flex-wrap: wrap;
    }

    .calorie-input-row input[type="number"] {
      flex: 1 1 160px;
      min-width: 0;
    }

    .macro-toggle-inline {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      border-radius: 12px;
      background: var(--surface-alt);
      color: var(--text-muted);
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .macro-toggle-inline:hover {
      background: var(--surface-highlight);
      color: var(--text-strong);
    }

    .macro-toggle-inline input[type="checkbox"] {
      width: auto;
      accent-color: var(--accent);
    }

    .meal-log {
      margin-top: 18px;
    }

    .meal-log-toggle {
      background: var(--surface-alt);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 14px 18px;
    }

    .meal-log-toggle > summary {
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      cursor: pointer;
      font-weight: 600;
      padding: 2px 0;
    }

    .meal-log-toggle > summary::-webkit-details-marker {
      display: none;
    }

    .meal-log-toggle > summary::after,
    .meal-type-block > summary::after {
      content: '\f078';
      font-family: 'Font Awesome 6 Free';
      font-weight: 900;
      font-size: 0.75rem;
      color: var(--text-muted);
      transition: transform 0.2s ease;
    }

    .meal-log-toggle[open] > summary::after,
    .meal-type-block[open] > summary::after {
      transform: rotate(180deg);
    }

    .meal-log-summary {
      color: var(--text-muted);
      font-size: 0.85rem;
      font-weight: 500;
    }

    .macro-highlight {
      margin-top: 16px;
      padding: 14px 16px;
      border-radius: 14px;
      background: rgba(21, 197, 163, 0.12);
      color: var(--text-muted);
      font-size: 0.9rem;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .macro-highlight.active {
      background: rgba(21, 197, 163, 0.2);
      color: var(--text-strong);
    }

    .macro-section {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .meal-sections {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }

    .meal-type-block {
      background: var(--surface);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 12px 14px;
    }

    .meal-type-block > summary {
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      cursor: pointer;
      font-weight: 600;
      padding: 2px 0;
    }

    .meal-type-block > summary::-webkit-details-marker {
      display: none;
    }

    .meal-type-info {
      color: var(--text-muted);
      font-size: 0.8rem;
    }

    .meal-type-empty {
      padding: 14px;
      text-align: center;
      color: var(--text-muted);
      background: rgba(255, 255, 255, 0.04);
      border-radius: 10px;
      margin-top: 8px;
    }

    .summary-card[data-metric="protein"] .value,
    .summary-card[data-metric="carbs"] .value,
    .summary-card[data-metric="fat"] .value {
      font-size: 1.15rem;
    }

    .history-list {
      max-height: none;
      overflow-y: visible;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .history-item {
      padding: 12px 14px;
      background: var(--surface-alt);
      border-radius: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    .history-more-note {
      text-align: center;
      font-size: 0.8rem;
      color: var(--text-muted);
      padding-top: 4px;
    }

    .history-item:hover {
      transform: translateY(-2px);
      background: var(--surface-highlight);
    }

    .empty-state {
      color: var(--text-muted);
      font-size: 0.9rem;
      text-align: center;
      padding: 20px 10px;
    }

    .weight-widget {
      background: linear-gradient(120deg, rgba(47, 62, 89, 0.9), rgba(21, 197, 163, 0.15));
      border-radius: 18px;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: transform 0.2s ease;
      border: 1px solid rgba(21, 197, 163, 0.2);
      box-shadow: 0 18px 36px rgba(21, 197, 163, 0.12);
    }

    .weight-widget:hover {
      transform: translateY(-3px);
    }

    .weight-widget h3 {
      margin: 0 0 6px;
      font-size: 1rem;
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    .weight-value {
      font-size: 2rem;
      font-weight: 600;
    }

    .weight-trend {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .trend-up {
      color: var(--danger);
    }

    .trend-down {
      color: var(--success);
    }

    .trend-flat {
      color: var(--text-muted);
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(5, 7, 12, 0.75);
      backdrop-filter: blur(6px);
      z-index: 40;
      padding: 30px;
    }

    .modal.open {
      display: flex;
    }

    .modal-content {
      background: var(--surface);
      border-radius: 18px;
      padding: 26px;
      width: min(840px, 95vw);
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .modal-content.large {
      width: min(960px, 96vw);
    }

    .chart-zoom-body {
      display: grid;
      gap: 20px;
    }

    .chart-zoom-canvas {
      padding: 12px;
      border-radius: 16px;
      background: var(--surface-alt);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .chart-zoom-details {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 16px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      font-size: 0.95rem;
      color: var(--text-muted);
    }

    .chart-zoom-details h4 {
      margin: 0;
      font-size: 1rem;
      color: var(--text-strong);
    }

    .chart-zoom-details ul {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .chart-zoom-details li strong {
      color: var(--text-strong);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 18px;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1.2rem;
    }

    .close-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.4rem;
      cursor: pointer;
    }

    .preset-editor {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .preset-row {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr)) 44px;
      gap: 10px;
      padding: 16px;
      background: var(--surface-alt);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .preset-row button {
      height: 44px;
      border-radius: 12px;
    }

    .history-manager {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .history-manager-controls {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .history-manager-controls select {
      background: var(--surface-alt);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 8px 12px;
      color: var(--text-strong);
    }

    .history-edit-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .history-edit-row {
      background: var(--surface-alt);
      border-radius: 14px;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .history-edit-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .history-edit-grid label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .history-edit-grid input,
    .history-edit-grid textarea {
      width: 100%;
      background: var(--surface);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 10px 12px;
      color: var(--text-strong);
    }

    .history-edit-grid textarea {
      min-height: 80px;
      resize: vertical;
    }

    .history-edit-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .history-edit-empty {
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      background: rgba(255, 255, 255, 0.04);
      border-radius: 12px;
      border: 1px dashed rgba(255, 255, 255, 0.1);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
    }

    .settings-card {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .settings-card p {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .pace-panel {
      margin-top: 18px;
      background: var(--surface-alt);
      border-radius: 14px;
      padding: 18px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .pace-header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    .pace-title {
      text-transform: uppercase;
      font-size: 0.8rem;
      letter-spacing: 0.6px;
      color: var(--text-muted);
    }

    .pace-summary {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .pace-card {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 12px 14px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      flex-direction: column;
      gap: 6px;
      cursor: pointer;
    }

    .pace-card.active {
      border-color: rgba(21, 197, 163, 0.6);
      box-shadow: 0 10px 20px rgba(21, 197, 163, 0.15);
    }

    .pace-card h4 {
      margin: 0;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--text-muted);
    }

    .pace-card .pace-value {
      font-size: 1.4rem;
      font-weight: 600;
    }

    .pace-card .pace-note {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .form-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
    }

    .segmented {
      display: inline-flex;
      border-radius: 12px;
      background: var(--surface-alt);
      padding: 4px;
      gap: 4px;
    }

    .segmented button {
      border: none;
      background: transparent;
      color: var(--text-muted);
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .segmented button.active {
      background: var(--accent);
      color: #04141a;
      box-shadow: 0 6px 14px rgba(21, 197, 163, 0.25);
    }

    .macro-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .macro-toggle input[type="checkbox"] {
      width: auto;
    }

    .alert {
      padding: 12px 16px;
      border-radius: 12px;
      background: rgba(247, 95, 120, 0.12);
      border: 1px solid rgba(247, 95, 120, 0.35);
      color: #ff92a8;
      font-size: 0.85rem;
      display: none;
    }

    .alert.visible {
      display: block;
    }

    .alert.success {
      background: rgba(92, 215, 184, 0.12);
      border-color: rgba(92, 215, 184, 0.4);
      color: #7ff0d1;
    }

    .chart-scroll {
      overflow-x: auto;
    }

    .chart-scroll canvas {
      min-width: 640px;
    }

    .metric-insight {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .metric-insight .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
    }

    .metric-insight .stat-card {
      background: var(--surface-alt);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .metric-insight .stat-card .label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--text-muted);
    }

    .metric-insight .stat-card .value {
      font-size: 1.2rem;
      font-weight: 600;
    }

    .metric-insight .stat-card.diff-surplus {
      border-color: rgba(247, 95, 120, 0.35);
      color: #ff92a8;
    }

    .metric-insight .stat-card.diff-deficit {
      border-color: rgba(92, 215, 184, 0.35);
      color: #7ff0d1;
    }

    .metric-insight .top-contributor,
    .metric-insight .info-block {
      background: var(--surface-alt);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .metric-insight .top-contributor h4 {
      margin: 0;
      font-size: 1rem;
      color: var(--text-strong);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .metric-insight .top-contributor p {
      margin: 0;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .metric-insight .info-block h4 {
      margin: 0;
      font-size: 1rem;
      color: var(--text-strong);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .metric-insight .info-block p {
      margin: 0;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .metric-insight .info-block strong {
      color: var(--text-strong);
    }

    .metric-insight table {
      width: 100%;
      border-collapse: collapse;
      border-radius: 14px;
      overflow: hidden;
      background: var(--surface-alt);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .metric-insight th,
    .metric-insight td {
      padding: 10px 14px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .metric-insight tbody tr:last-child td {
      border-bottom: none;
    }

    .metric-insight th {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--text-muted);
    }

    .metric-insight td {
      font-size: 0.9rem;
      color: var(--text-strong);
    }

    .metric-insight td .subtext {
      display: block;
      color: var(--text-muted);
      font-size: 0.8rem;
      margin-top: 2px;
    }

    .metric-insight .empty-state {
      margin: 0;
    }

    .weight-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .weight-tabs button {
      padding: 8px 16px;
    }

    .weight-tabs button[disabled] {
      opacity: 0.45;
      cursor: not-allowed;
      pointer-events: none;
    }

    .weight-range-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .weight-custom-range {
      display: none;
      gap: 12px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .weight-custom-range.visible {
      display: flex;
    }

    .weight-custom-range label {
      font-size: 0.8rem;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .weight-custom-range input[type="date"] {
      background: var(--surface-alt);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 8px 12px;
      color: var(--text-strong);
      font-size: 0.9rem;
    }

    .weight-range-controls label {
      font-size: 0.8rem;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .weight-range-controls select {
      background: var(--surface-alt);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 8px 12px;
      color: var(--text-strong);
      font-size: 0.9rem;
    }

    .eta {
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-top: 10px;
    }

    @media (max-width: 1100px) {
      .overview-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 720px) {
      header {
        padding: 20px;
      }

      main {
        padding: 24px;
      }

      .summary-banner {
        margin: 0 0 16px;
      }

      .preset-row {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        grid-auto-rows: minmax(0, auto);
      }

      .preset-row button {
        grid-column: span 2;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="top-row">
      <div>
        <h1><i class="fa-solid fa-bowl-food"></i> OwnYourPrime Meal Tracker</h1>
        <div class="tagline">Precision logging, intelligent trends, and coach-level feedback</div>
      </div>
    </div>
    <nav>
      <button class="active" data-page="overview"><i class="fa-solid fa-gauge"></i> Overview</button>
      <button data-page="analytics"><i class="fa-solid fa-chart-line"></i> Analytics</button>
      <button data-page="settings"><i class="fa-solid fa-gear"></i> Settings</button>
    </nav>
  </header>

  <main>
    <div id="summaryCelebration" class="summary-banner celebration" role="status" aria-live="polite"></div>
    <div id="summaryWarning" class="summary-banner warning" role="alert" aria-live="assertive"></div>
    <section id="overviewPage" class="page active">
      <div class="overview-grid">
        <aside class="summary-stack">
          <div class="card">
            <div class="card-header-controls">
              <h2><i class="fa-solid fa-calendar-day"></i> Today</h2>
              <button type="button" class="ghost-button" id="toggleMacroSection" aria-expanded="true">
                <i class="fa-solid fa-eye-slash"></i> Hide macros
              </button>
            </div>
            <div class="form-row">
              <div style="flex:1;">
                <label for="dateInput">Date</label>
                <input type="date" id="dateInput">
              </div>
            </div>
            <div id="macroSection" class="macro-section">
              <div id="summaryCards" class="summary-stack"></div>
            </div>
            <div id="macroHighlight" class="macro-highlight">Click a nutrient card to open detailed insights.</div>
          </div>
          <div class="card">
            <h2><i class="fa-solid fa-droplet"></i> Hydration</h2>
            <div class="water-block">
              <div class="water-actions">
                <input type="number" id="waterInput" placeholder="Add water (ml)" min="0">
                <button class="primary" id="addWaterBtn"><i class="fa-solid fa-plus"></i></button>
              </div>
              <button class="secondary" id="quickWaterBtn"><i class="fa-solid fa-glass-water"></i> Quick add 250 ml</button>
              <div class="summary-card" style="margin-top: 4px;">
                <div class="summary-icon"><i class="fa-solid fa-droplet"></i></div>
                <div class="summary-details">
                  <div class="value"><span id="waterTotal">0</span> ml</div>
                  <div class="label">Target <span id="waterTargetLabel">—</span> ml</div>
                  <div class="progress-track"><div id="waterProgress" class="progress-fill" style="width:0;"></div></div>
                </div>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="weight-widget" id="weightWidget">
              <div>
                <h3>Weight</h3>
                <div class="weight-value" id="weightValue">--</div>
                <div class="weight-trend" id="weightTrend"><i class="fa-solid fa-minus"></i> No data</div>
              </div>
              <div class="summary-icon" style="font-size:1.8rem;"><i class="fa-solid fa-chart-line"></i></div>
            </div>
          </div>
          <div class="card">
            <h2><i class="fa-solid fa-clock-rotate-left"></i> History</h2>
            <div id="historyList" class="history-list"></div>
            <button class="secondary" id="openHistoryManager" style="margin-top:12px; width:100%;"><i class="fa-solid fa-pen-to-square"></i> Manage entries</button>
          </div>
        </aside>
        <section class="card" style="display:flex; flex-direction:column; gap:26px;">
          <div>
            <h2><i class="fa-solid fa-bolt"></i> Quick Presets</h2>
            <div id="presetButtons" class="quick-presets"></div>
            <div class="empty-state" id="noPresets" style="display:none;">No presets yet. Configure them in Settings → Preset Meals.</div>
          </div>
          <div>
            <h2><i class="fa-solid fa-utensils"></i> Add Meal</h2>
            <div class="meal-type-options" id="mealTypeOptions" role="group" aria-label="Select meal type">
              <button type="button" class="secondary" data-meal-type="breakfast">Breakfast</button>
              <button type="button" class="secondary" data-meal-type="lunch">Lunch</button>
              <button type="button" class="secondary" data-meal-type="snack">Snack</button>
              <button type="button" class="secondary" data-meal-type="dinner">Dinner</button>
            </div>
            <form id="mealForm" style="display:flex; flex-direction:column; gap:14px;">
              <div>
                <label for="mealName">Meal Name</label>
                <input type="text" id="mealName" placeholder="e.g. Breakfast Bowl">
              </div>
              <div class="form-row meal-meta-row">
                <div class="calorie-group">
                  <label for="calories">Calories (kcal)</label>
                  <div class="calorie-input-row">
                    <input type="number" id="calories" min="0" step="1">
                    <label class="macro-toggle-inline" for="showMacros">
                      <input type="checkbox" id="showMacros">
                      <span>Track macros</span>
                    </label>
                  </div>
                </div>
                <div class="time-field">
                  <label for="mealTime">Time</label>
                  <input type="time" id="mealTime" step="60">
                </div>
              </div>
              <div id="macroFields" style="display:none;" class="form-row">
                <div>
                  <label for="protein">Protein (g)</label>
                  <input type="number" id="protein" min="0" step="1">
                </div>
                <div>
                  <label for="carbs">Carbs (g)</label>
                  <input type="number" id="carbs" min="0" step="1">
                </div>
                <div>
                  <label for="fat">Fat (g)</label>
                  <input type="number" id="fat" min="0" step="1">
                </div>
              </div>
              <div>
                <label for="ingredients">Ingredients</label>
                <textarea id="ingredients" class="ingredients-area" placeholder="Chicken, quinoa, spinach..."></textarea>
              </div>
              <div style="display:flex; justify-content:flex-end;">
                <button class="primary" type="submit"><i class="fa-solid fa-plus"></i> Log Meal</button>
              </div>
            </form>
            <div class="meal-log">
              <details id="mealLogToggle" class="meal-log-toggle" open>
                <summary>
                  <span>Today's meals</span>
                  <span id="mealLogSummary" class="meal-log-summary"></span>
                </summary>
                <div id="mealSections" class="meal-sections"></div>
              </details>
            </div>
          </div>
        </section>
      </div>
    </section>

    <section id="analyticsPage" class="page">
      <div class="analytics-hero card">
        <div class="analytics-hero-header">
          <h2><i class="fa-solid fa-chart-line"></i> Performance Pulse</h2>
          <p>Explore the bigger picture across calories, macros, hydration, timing, and weight momentum.</p>
        </div>
        <div class="analytics-stat-grid">
          <div class="stat-card">
            <span class="stat-label">Total weight change</span>
            <span class="stat-value" id="weightChangeValue">--</span>
            <span class="stat-note" id="weightChangeDirection">Log weights to unlock trends.</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">Days to target</span>
            <span class="stat-value" id="targetCountdownValue">--</span>
            <span class="stat-note">Based on your selected pace.</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">Remaining to goal</span>
            <span class="stat-value" id="weightRemainingValue">--</span>
            <span class="stat-note" id="weightRemainingLabel">Set a goal weight in Settings to see this.</span>
          </div>
        </div>
      </div>
      <div class="analytics-grid">
        <div class="card analytics-card" data-chart="calories" tabindex="0" role="button">
          <div class="analytics-card-header">
            <div>
              <h3><i class="fa-solid fa-fire"></i> Calorie trend</h3>
              <p class="analytics-card-subtitle">7-day energy view</p>
            </div>
            <span class="chart-hint"><i class="fa-solid fa-up-right-and-down-left-from-center"></i> Zoom</span>
          </div>
          <canvas id="calorieChart" height="220"></canvas>
          <div class="chart-note">Hover for daily totals, tap to deep dive.</div>
        </div>
        <div class="card analytics-card" data-chart="macro" tabindex="0" role="button">
          <div class="analytics-card-header">
            <div>
              <h3><i class="fa-solid fa-utensils"></i> Macro balance</h3>
              <p class="analytics-card-subtitle">Protein · Carbs · Fat</p>
            </div>
            <span class="chart-hint"><i class="fa-solid fa-up-right-and-down-left-from-center"></i> Zoom</span>
          </div>
          <canvas id="macroChart" height="220"></canvas>
          <div class="chart-note">Keep macros proportional to your plan.</div>
        </div>
        <div class="card analytics-card" data-chart="water" tabindex="0" role="button">
          <div class="analytics-card-header">
            <div>
              <h3><i class="fa-solid fa-droplet"></i> Hydration</h3>
              <p class="analytics-card-subtitle">Last 7 days</p>
            </div>
            <span class="chart-hint"><i class="fa-solid fa-up-right-and-down-left-from-center"></i> Zoom</span>
          </div>
          <canvas id="waterChart" height="220"></canvas>
          <div class="chart-note" id="waterSummary"></div>
        </div>
        <div class="card analytics-card" data-chart="mealSplit" tabindex="0" role="button">
          <div class="analytics-card-header">
            <div>
              <h3><i class="fa-solid fa-clock"></i> Meals</h3>
              <p class="analytics-card-subtitle">Calorie share by meal</p>
            </div>
            <span class="chart-hint"><i class="fa-solid fa-up-right-and-down-left-from-center"></i> Zoom</span>
          </div>
          <canvas id="mealSplitChart" height="220"></canvas>
          <div class="chart-note" id="mealSplitInfo">Add meal times to unlock meal insights.</div>
        </div>
        <div class="card analytics-card weight-projection-card" data-chart="weight" tabindex="0" role="button">
          <div class="analytics-card-header">
            <div>
              <h3><i class="fa-solid fa-scale-balanced"></i> Weight projection</h3>
              <p class="analytics-card-subtitle">Current · projected · goal</p>
            </div>
            <span class="chart-hint"><i class="fa-solid fa-circle-info"></i> Details</span>
          </div>
          <div class="weight-projection-chart">
            <canvas id="weightProjectionCanvas" height="240" aria-label="Weight trajectory"></canvas>
            <div class="weight-chart-empty" id="weightProjectionEmpty">Log meals with calories and weight entries to unlock projections.</div>
          </div>
          <div class="chart-note" id="weightCardSummary">Log meals with calories and weight entries to unlock projections.</div>
        </div>
      </div>
    </section>

    <section id="settingsPage" class="page">
      <div class="card settings-card">
        <h2><i class="fa-solid fa-user"></i> Profile</h2>
        <p>Keep these details current for accurate calorie estimates, BMI, and safe goal suggestions.</p>
        <form id="profileForm" class="settings-grid">
          <div>
            <label for="ageInput">Age</label>
            <input type="number" id="ageInput" min="1">
          </div>
          <div>
            <label for="weightInput">Current Weight (kg)</label>
            <input type="number" id="weightInput" min="0" step="0.1">
          </div>
          <div>
            <label for="heightInput">Height (cm)</label>
            <input type="number" id="heightInput" min="0" step="0.1">
          </div>
          <div>
            <label for="lifestyleInput">Activity level</label>
            <select id="lifestyleInput">
              <option value="sedentary">Sedentary</option>
              <option value="light">Lightly active</option>
              <option value="moderate">Moderately active</option>
              <option value="active">Active</option>
              <option value="athlete">Athlete</option>
            </select>
          </div>
        </form>
        <div class="summary-card" style="margin-top:10px;">
          <div class="summary-icon"><i class="fa-solid fa-heart-pulse"></i></div>
          <div class="summary-details">
            <div class="value">BMI <span id="bmiValue">--</span></div>
            <div class="label" id="bmiLabel">Update profile for BMI</div>
            <div class="progress-track"><div id="bmiProgress" class="progress-fill" style="width:0;"></div></div>
          </div>
        </div>
      </div>

          <div class="card settings-card">
            <h2><i class="fa-solid fa-bullseye"></i> Targets & Safety</h2>
            <p>All targets power the dashboard. Guardrails ensure a sustainable pace.</p>
            <form id="targetsForm" class="settings-grid">
              <div>
            <label for="targetCalories">Daily Calories (kcal)</label>
            <input type="number" id="targetCalories" min="0" step="1">
          </div>
          <div>
            <label for="targetProtein">Protein (g)</label>
            <input type="number" id="targetProtein" min="0" step="1">
          </div>
          <div>
            <label for="targetCarbs">Carbs (g)</label>
            <input type="number" id="targetCarbs" min="0" step="1">
          </div>
          <div>
            <label for="targetFat">Fat (g)</label>
            <input type="number" id="targetFat" min="0" step="1">
          </div>
          <div>
            <label for="targetWater">Water (ml)</label>
            <input type="number" id="targetWater" min="0" step="50">
          </div>
          <div>
            <label for="targetWeight">Goal Weight (kg)</label>
            <input type="number" id="targetWeight" min="0" step="0.1">
          </div>
          <div>
            <label>Goal type</label>
            <div class="segmented" id="goalTypeGroup">
              <button type="button" data-goal="loss">Loss</button>
              <button type="button" data-goal="maintain" class="active">Maintain</button>
              <button type="button" data-goal="gain">Gain</button>
            </div>
            <div class="goal-type-hint" id="goalTypeHint"></div>
          </div>
        </form>
        <div class="pace-panel">
          <div class="pace-header">
            <span class="pace-title">Goal timeline (auto)</span>
            <div class="segmented" id="paceSelector">
              <button type="button" data-pace="slow">Slow</button>
              <button type="button" data-pace="normal" class="active">Normal</button>
              <button type="button" data-pace="fast">Fast</button>
              <button type="button" data-pace="extreme">Extreme</button>
            </div>
          </div>
          <div id="paceSummary" class="pace-summary"></div>
          <input type="hidden" id="goalTimeline" value="12">
        </div>
        <div id="targetAlert" class="alert"></div>
        <div id="targetSuccess" class="alert success"></div>
        <div style="display:flex; justify-content:flex-end; margin-top:16px; gap:10px;">
          <button class="secondary" id="openPresetEditor"><i class="fa-solid fa-pen-to-square"></i> Preset Meals</button>
          <button class="primary" id="saveSettings"><i class="fa-solid fa-floppy-disk"></i> Save Settings</button>
        </div>
      </div>
    </section>
  </main>

  <div id="presetModal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3><i class="fa-solid fa-rectangle-list"></i> Preset Meals</h3>
        <button class="close-btn" data-close="presetModal"><i class="fa-solid fa-xmark"></i></button>
      </div>
      <p style="color:var(--text-muted); margin-bottom:14px;">Create up to 10 presets for rapid logging. Macros are optional.</p>
      <div id="presetLimit" class="alert" style="margin-bottom:12px;"></div>
      <div class="preset-editor" id="presetEditor"></div>
      <div style="display:flex; justify-content:space-between; margin-top:16px;">
        <button class="secondary" id="addPresetRow"><i class="fa-solid fa-plus"></i> Add preset</button>
        <button class="primary" id="savePresets"><i class="fa-solid fa-floppy-disk"></i> Save presets</button>
      </div>
    </div>
  </div>

  <div id="weightModal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3><i class="fa-solid fa-scale-balanced"></i> Weight Trend</h3>
        <button class="close-btn" data-close="weightModal"><i class="fa-solid fa-xmark"></i></button>
      </div>
      <form id="weightForm" style="display:flex; gap:12px; margin-bottom:16px;">
        <div>
          <label for="weightDate">Date</label>
          <input type="date" id="weightDate">
        </div>
        <div>
          <label for="weightEntry">Weight (kg)</label>
          <input type="number" id="weightEntry" min="0" step="0.1">
        </div>
        <div style="align-self:flex-end;">
          <button class="primary" type="submit"><i class="fa-solid fa-plus"></i> Add</button>
        </div>
      </form>
      <div class="weight-tabs">
        <button class="secondary" data-range="daily">Daily</button>
        <button class="secondary" data-range="weekly">Weekly</button>
        <button class="secondary" data-range="monthly">Monthly</button>
      </div>
      <div class="weight-range-controls">
        <label for="weightRangeLength">Range</label>
        <select id="weightRangeLength">
          <option value="30">Last 30 days</option>
          <option value="90" selected>Last 90 days</option>
          <option value="180">Last 180 days</option>
          <option value="custom">Custom range</option>
        </select>
      </div>
      <div class="weight-custom-range" id="weightCustomRange">
        <div>
          <label for="weightRangeStart">Start</label>
          <input type="date" id="weightRangeStart">
        </div>
        <div>
          <label for="weightRangeEnd">End</label>
          <input type="date" id="weightRangeEnd">
        </div>
      </div>
      <div class="card" style="background:var(--surface-alt);">
        <div class="chart-scroll">
          <canvas id="weightTrendChart" height="260"></canvas>
        </div>
      </div>
      <div class="eta" id="etaText"></div>
    </div>
  </div>

  <div id="chartZoomModal" class="modal" aria-hidden="true">
    <div class="modal-content large">
      <div class="modal-header">
        <h3 id="chartZoomTitle"><i class="fa-solid fa-chart-line"></i> Chart insights</h3>
        <button class="close-btn" data-close="chartZoomModal"><i class="fa-solid fa-xmark"></i></button>
      </div>
      <div class="chart-zoom-body">
        <div class="chart-zoom-canvas">
          <canvas id="chartZoomCanvas" height="360"></canvas>
        </div>
        <div id="chartZoomDetails" class="chart-zoom-details"></div>
      </div>
    </div>
  </div>

  <div id="historyModal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3><i class="fa-solid fa-pen-to-square"></i> Edit Meal History</h3>
        <button class="close-btn" data-close="historyModal"><i class="fa-solid fa-xmark"></i></button>
      </div>
        <div class="history-manager">
          <div class="history-manager-controls">
            <label for="historyDateInput">Select day</label>
            <input type="date" id="historyDateInput">
          </div>
        <div id="historyEntries" class="history-edit-list"></div>
      </div>
    </div>
  </div>

  <div id="calorieModal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="calorieModalTitle"><i class="fa-solid fa-fire"></i> Daily Calorie Insight</h3>
        <button class="close-btn" data-close="calorieModal"><i class="fa-solid fa-xmark"></i></button>
      </div>
      <div id="calorieSummary" class="metric-insight"></div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const navButtons = document.querySelectorAll('nav button');
    const dateInput = document.getElementById('dateInput');
    const mealSections = document.getElementById('mealSections');
    const mealLogSummary = document.getElementById('mealLogSummary');
    const mealTypeOptions = document.getElementById('mealTypeOptions');
    const mealLogToggle = document.getElementById('mealLogToggle');
    const summaryCards = document.getElementById('summaryCards');
    const waterTotal = document.getElementById('waterTotal');
    const waterProgress = document.getElementById('waterProgress');
    const waterTargetLabel = document.getElementById('waterTargetLabel');
    const addWaterBtn = document.getElementById('addWaterBtn');
    const quickWaterBtn = document.getElementById('quickWaterBtn');
    const waterInput = document.getElementById('waterInput');
    const mealForm = document.getElementById('mealForm');
    const mealTimeInput = document.getElementById('mealTime');
    const showMacros = document.getElementById('showMacros');
    const macroFields = document.getElementById('macroFields');
    const presetButtonsContainer = document.getElementById('presetButtons');
    const noPresets = document.getElementById('noPresets');
    const historyList = document.getElementById('historyList');
    const openHistoryManagerBtn = document.getElementById('openHistoryManager');
    const weightWidget = document.getElementById('weightWidget');
    const weightValue = document.getElementById('weightValue');
    const weightTrend = document.getElementById('weightTrend');
    const summaryCelebration = document.getElementById('summaryCelebration');
    const summaryWarning = document.getElementById('summaryWarning');
    const waterSummary = document.getElementById('waterSummary');
    const mealSplitInfo = document.getElementById('mealSplitInfo');
    const macroHighlight = document.getElementById('macroHighlight');
    const macroSection = document.getElementById('macroSection');
    const toggleMacroSectionBtn = document.getElementById('toggleMacroSection');
    const analyticsCards = document.querySelectorAll('.analytics-card[data-chart]');
    const chartZoomModal = document.getElementById('chartZoomModal');
    const chartZoomTitle = document.getElementById('chartZoomTitle');
    const chartZoomDetails = document.getElementById('chartZoomDetails');
    const chartZoomCanvas = document.getElementById('chartZoomCanvas');
    const weightChangeValue = document.getElementById('weightChangeValue');
    const weightChangeDirection = document.getElementById('weightChangeDirection');
    const weightRemainingValue = document.getElementById('weightRemainingValue');
    const weightRemainingLabel = document.getElementById('weightRemainingLabel');
    const targetCountdownValue = document.getElementById('targetCountdownValue');
    const weightCardSummary = document.getElementById('weightCardSummary');
    const weightProjectionCanvas = document.getElementById('weightProjectionCanvas');
    const weightProjectionEmpty = document.getElementById('weightProjectionEmpty');
    const weightTrendCanvas = document.getElementById('weightTrendChart');

    const ageInput = document.getElementById('ageInput');
    const weightInput = document.getElementById('weightInput');
    const heightInput = document.getElementById('heightInput');
    const lifestyleInput = document.getElementById('lifestyleInput');
    const bmiValue = document.getElementById('bmiValue');
    const bmiLabel = document.getElementById('bmiLabel');
    const bmiProgress = document.getElementById('bmiProgress');

    const targetCalories = document.getElementById('targetCalories');
    const targetProtein = document.getElementById('targetProtein');
    const targetCarbs = document.getElementById('targetCarbs');
    const targetFat = document.getElementById('targetFat');
    const targetWater = document.getElementById('targetWater');
    const targetWeight = document.getElementById('targetWeight');
    const goalTimeline = document.getElementById('goalTimeline');
    const goalTypeGroup = document.getElementById('goalTypeGroup');
    const goalTypeHint = document.getElementById('goalTypeHint');
    const targetAlert = document.getElementById('targetAlert');
    const targetSuccess = document.getElementById('targetSuccess');
    const saveSettingsBtn = document.getElementById('saveSettings');
    const paceSelector = document.getElementById('paceSelector');
    const paceSummary = document.getElementById('paceSummary');

    const presetModal = document.getElementById('presetModal');
    const presetEditor = document.getElementById('presetEditor');
    const presetLimit = document.getElementById('presetLimit');
    const addPresetRow = document.getElementById('addPresetRow');
    const savePresetsBtn = document.getElementById('savePresets');
    const openPresetEditorBtn = document.getElementById('openPresetEditor');

    const weightModal = document.getElementById('weightModal');
    const weightDate = document.getElementById('weightDate');
    const weightEntry = document.getElementById('weightEntry');
    const weightForm = document.getElementById('weightForm');
    const weightTabs = document.querySelectorAll('.weight-tabs button');
    const weightRangeLength = document.getElementById('weightRangeLength');
    const weightRangeStart = document.getElementById('weightRangeStart');
    const weightRangeEnd = document.getElementById('weightRangeEnd');
    const weightCustomRange = document.getElementById('weightCustomRange');
    const etaText = document.getElementById('etaText');
    const calorieModal = document.getElementById('calorieModal');
    const calorieModalTitle = document.getElementById('calorieModalTitle');
    const calorieSummary = document.getElementById('calorieSummary');
    const historyModal = document.getElementById('historyModal');
    const historyDateInput = document.getElementById('historyDateInput');
    const historyEntries = document.getElementById('historyEntries');

    let calorieChart, macroChart, waterChart, mealSplitChart, weightProjectionChart, weightTrendChart;
    let chartZoomInstance;
    const analyticsCache = {
      calories: { labels: [], data: [], target: 0, loggedAverage: 0, maintenance: 0, averageDelta: 0, weeklyDeltaKg: 0, loggedDays: 0 },
      macros: { protein: 0, carbs: 0, fat: 0, targets: {} },
      water: { labels: [], data: [], target: 0, today: 0, average: 0 },
      mealSplit: { totals: {}, averages: {} },
      weight: {}
    };
    let selectedGoalType = 'maintain';
    let selectedWeightRange = 'daily';
    let selectedPace = 'normal';
    let latestSummary = { calories: 0, protein: 0, carbs: 0, fat: 0, water: 0 };
    let manualMealTypeSelection = false;
    let selectedMealType = '';

    setDefaultMealTime();

    const defaultProfile = {
      age: 30,
      weight: 70,
      height: 175,
      lifestyle: 'moderate'
    };

    const defaultTargets = {
      calories: 2200,
      protein: 130,
      carbs: 240,
      fat: 70,
      water: 2500,
      weightTarget: 70,
      goalType: 'maintain',
      goalTimeline: 12,
      goalPace: 'normal'
    };

    const defaultPresets = [
      { name: 'Chicken Power Bowl', ingredients: 'Grilled chicken, quinoa, kale, avocado', calories: 520, protein: 45, carbs: 42, fat: 18 },
      { name: 'Greek Yogurt Parfait', ingredients: 'Yogurt, berries, granola, chia', calories: 320, protein: 22, carbs: 38, fat: 9 },
      { name: 'Salmon & Greens', ingredients: 'Baked salmon, asparagus, lemon', calories: 410, protein: 38, carbs: 6, fat: 24 }
    ];

    const mealTypes = [
      { key: 'breakfast', label: 'Breakfast' },
      { key: 'lunch', label: 'Lunch' },
      { key: 'snack', label: 'Snack' },
      { key: 'dinner', label: 'Dinner' }
    ];

    const paceRates = {
      slow: { rate: 0.25, label: 'Slow' },
      normal: { rate: 0.5, label: 'Normal' },
      fast: { rate: 1, label: 'Fast' },
      extreme: { rate: 1.5, label: 'Extreme' }
    };

    const KCAL_PER_KG = 7700;
    const MS_PER_DAY = 86400000;
    const STORAGE_KEYS = {
      profile: 'lifeos:meals:profile',
      targets: 'lifeos:meals:targets',
      presets: 'lifeos:meals:presets',
      weights: 'lifeos:meals:weights'
    };
    const LEGACY_STORAGE_KEYS = {
      profile: 'profile',
      targets: 'targets',
      presets: 'presets',
      weights: 'weights'
    };

    function safeParseJSON(raw, fallback, keyForQuarantine = '') {
      if (typeof raw !== 'string') return fallback;
      try {
        return JSON.parse(raw);
      } catch (error) {
        console.warn(`Invalid JSON in storage key "${keyForQuarantine}"`, error);
        if (keyForQuarantine) {
          localStorage.setItem(`${keyForQuarantine}__corrupt__${Date.now()}`, raw);
          localStorage.removeItem(keyForQuarantine);
        }
        return fallback;
      }
    }

    function safeGetStorage(key, fallback = null) {
      const raw = localStorage.getItem(key);
      return raw ? safeParseJSON(raw, fallback, key) : fallback;
    }

    function safeSetStorage(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    }

    function mealKey(date) { return `lifeos:meals:entries:${date}`; }
    function waterKey(date) { return `lifeos:meals:water:${date}`; }

    function migrateStorageKeys() {
      Object.entries(STORAGE_KEYS).forEach(([name, nextKey]) => {
        if (localStorage.getItem(nextKey) !== null) return;
        const legacyKey = LEGACY_STORAGE_KEYS[name];
        const legacyRaw = localStorage.getItem(legacyKey);
        if (legacyRaw === null) return;
        const parsed = safeParseJSON(legacyRaw, null, legacyKey);
        if (parsed !== null) safeSetStorage(nextKey, parsed);
        localStorage.removeItem(legacyKey);
      });
      const keysToMigrate = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (!key) continue;
        if (key.startsWith('meals_')) keysToMigrate.push(key);
        if (key.startsWith('water_')) keysToMigrate.push(key);
      }
      keysToMigrate.forEach((legacyKey) => {
        const isMeals = legacyKey.startsWith('meals_');
        const date = legacyKey.slice(isMeals ? 6 : 6);
        const targetKey = isMeals ? mealKey(date) : waterKey(date);
        if (localStorage.getItem(targetKey) !== null) return;
        const raw = localStorage.getItem(legacyKey);
        if (raw === null) return;
        if (isMeals) {
          const parsed = safeParseJSON(raw, [], legacyKey);
          safeSetStorage(targetKey, parsed);
        } else {
          const n = Number(raw);
          localStorage.setItem(targetKey, String(Number.isFinite(n) ? n : 0));
        }
        localStorage.removeItem(legacyKey);
      });
    }

    migrateStorageKeys();

    function navTo(page) {
      document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
      document.getElementById(page + 'Page').classList.add('active');
      navButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.page === page));
    }

    navButtons.forEach(btn => {
      btn.addEventListener('click', () => navTo(btn.dataset.page));
    });

    if (summaryCards) {
      summaryCards.addEventListener('click', event => {
        const card = event.target.closest('.summary-card');
        if (!card) return;
        openMetricInsight(card.dataset.metric);
      });
      summaryCards.addEventListener('keydown', event => {
        if (event.key !== 'Enter' && event.key !== ' ') return;
        const card = event.target.closest('.summary-card');
        if (!card) return;
        event.preventDefault();
        openMetricInsight(card.dataset.metric);
      });
    }

    if (toggleMacroSectionBtn && macroSection) {
      toggleMacroSectionBtn.addEventListener('click', () => {
        const collapsed = macroSection.classList.toggle('collapsed');
        const expanded = !collapsed;
        toggleMacroSectionBtn.setAttribute('aria-expanded', String(expanded));
        toggleMacroSectionBtn.innerHTML = expanded
          ? '<i class="fa-solid fa-eye-slash"></i> Hide macros'
          : '<i class="fa-solid fa-eye"></i> Show macros';
        if (macroHighlight) {
          macroHighlight.style.display = collapsed ? 'none' : '';
        }
      });
    }

    analyticsCards.forEach(card => {
      card.addEventListener('click', () => openChartZoom(card.dataset.chart));
      card.addEventListener('keydown', event => {
        if (event.key !== 'Enter' && event.key !== ' ') return;
        event.preventDefault();
        openChartZoom(card.dataset.chart);
      });
    });

    if (mealTypeOptions) {
      mealTypeOptions.addEventListener('click', event => {
        const button = event.target.closest('button[data-meal-type]');
        if (!button) return;
        const type = button.dataset.mealType;
        if (manualMealTypeSelection && selectedMealType === type) {
          manualMealTypeSelection = false;
          syncMealTypeWithTime(true);
          return;
        }
        manualMealTypeSelection = true;
        selectedMealType = type;
        updateMealTypeButtons(selectedMealType);
      });
    }

    if (mealTimeInput) {
      mealTimeInput.addEventListener('change', () => syncMealTypeWithTime(false));
      mealTimeInput.addEventListener('input', () => syncMealTypeWithTime(false));
    }

    function getProfile() {
      const stored = safeGetStorage(STORAGE_KEYS.profile, {});
      return { ...defaultProfile, ...(stored && typeof stored === 'object' ? stored : {}) };
    }

    function saveProfile(profile) {
      safeSetStorage(STORAGE_KEYS.profile, profile);
    }

    function getTargets() {
      const stored = safeGetStorage(STORAGE_KEYS.targets, {});
      return { ...defaultTargets, ...(stored && typeof stored === 'object' ? stored : {}) };
    }

    function saveTargets(targets) {
      safeSetStorage(STORAGE_KEYS.targets, targets);
    }

    function getPresets() {
      const parsed = safeGetStorage(STORAGE_KEYS.presets, defaultPresets);
      return Array.isArray(parsed) ? parsed : defaultPresets;
    }

    function savePresetData(presets) {
      safeSetStorage(STORAGE_KEYS.presets, presets);
    }

    function currentTimeValue() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      return `${hours}:${minutes}`;
    }

    function setDefaultMealTime() {
      if (mealTimeInput) {
        mealTimeInput.value = currentTimeValue();
        manualMealTypeSelection = false;
        syncMealTypeWithTime(true);
      }
    }

    function normaliseTime(value, fallback = currentTimeValue()) {
      if (!value) return fallback;
      const [hours, minutes] = String(value).split(':');
      if (hours === undefined || minutes === undefined) return fallback;
      return `${hours.padStart(2, '0')}:${minutes.padStart(2, '0')}`;
    }

    function formatMealTime(value) {
      if (!value) return '--:--';
      const [hours, minutes] = String(value).split(':');
      if (hours === undefined || minutes === undefined) return '--:--';
      return `${hours.padStart(2, '0')}:${minutes.padStart(2, '0')}`;
    }

    function timeStringToMinutes(value) {
      if (!value) return null;
      const [hours, minutes] = String(value).split(':').map(Number);
      if (Number.isNaN(hours) || Number.isNaN(minutes)) return null;
      return (hours * 60) + minutes;
    }

    function inferMealType(timeValue) {
      const minutes = timeStringToMinutes(timeValue);
      if (minutes === null) return 'snack';
      if (minutes >= 300 && minutes < 690) return 'breakfast';
      if (minutes >= 690 && minutes < 930) return 'lunch';
      if (minutes >= 930 && minutes < 1050) return 'snack';
      if (minutes >= 1050 && minutes < 1440) return 'dinner';
      return 'snack';
    }

    function formatMealTypeLabel(type) {
      const found = mealTypes.find(item => item.key === type);
      return found ? found.label : 'Meal';
    }

    function updateMealTypeButtons(type) {
      if (!mealTypeOptions) return;
      mealTypeOptions.querySelectorAll('button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mealType === type);
      });
    }

    function syncMealTypeWithTime(force = false) {
      if (!mealTimeInput) return;
      const inferred = inferMealType(normaliseTime(mealTimeInput.value));
      if (force || !manualMealTypeSelection) {
        selectedMealType = inferred;
        updateMealTypeButtons(selectedMealType);
        if (force) {
          manualMealTypeSelection = false;
        }
      }
      return inferred;
    }

    function determineMealTypeForTime(timeValue) {
      if (manualMealTypeSelection && selectedMealType) {
        return selectedMealType;
      }
      return inferMealType(timeValue);
    }

    function resolveMealType(meal) {
      if (meal && meal.type) return meal.type;
      return inferMealType(meal ? meal.time : '');
    }

    function escapeHtml(value) {
      const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };
      return String(value ?? '').replace(/[&<>"']/g, char => map[char]);
    }

    function calculateBMR(profile) {
      if (!profile.weight || !profile.height || !profile.age) return 0;
      return 10 * profile.weight + 6.25 * profile.height - 5 * profile.age + 5;
    }

    function activityMultiplier(level) {
      switch (level) {
        case 'sedentary': return 1.2;
        case 'light': return 1.375;
        case 'moderate': return 1.55;
        case 'active': return 1.725;
        case 'athlete': return 1.9;
        default: return 1.4;
      }
    }

    function calculateTDEE(profile) {
      const bmr = calculateBMR(profile);
      if (!bmr) return 0;
      return bmr * activityMultiplier(profile.lifestyle || 'moderate');
    }

    function getDraftProfile() {
      return {
        age: Number(ageInput.value) || defaultProfile.age,
        weight: Number(weightInput.value) || defaultProfile.weight,
        height: Number(heightInput.value) || defaultProfile.height,
        lifestyle: lifestyleInput.value || 'moderate'
      };
    }

    function computePaceData(profile, targetWeightValue) {
      const results = {};
      const tdee = calculateTDEE(profile);
      const maintenance = Math.round(tdee);
      const currentWeight = profile.weight || targetWeightValue || 0;
      const targetWeightSafe = targetWeightValue || currentWeight;
      const diff = targetWeightSafe - currentWeight;
      const absDiff = Math.abs(diff);
      const direction = absDiff < 0.05 ? 'maintain' : diff > 0 ? 'gain' : 'loss';

      Object.entries(paceRates).forEach(([key, meta]) => {
        let weeks = 0;
        let dailyDelta = 0;
        let calorieTarget = maintenance;
        if (direction !== 'maintain' && meta.rate > 0 && maintenance) {
          weeks = Math.max(1, Math.ceil(absDiff / meta.rate));
          dailyDelta = Math.round((meta.rate * KCAL_PER_KG) / 7);
          const adjust = direction === 'loss' ? -dailyDelta : dailyDelta;
          calorieTarget = Math.max(900, Math.round(maintenance + adjust));
        }
        results[key] = {
          label: meta.label,
          weeks,
          dailyDelta,
          calorieTarget,
          direction,
          rate: meta.rate,
          maintenance
        };
      });
      results.direction = direction;
      results.maintenance = maintenance;
      return results;
    }

    function updateGoalTypeHint() {
      if (!goalTypeHint) return;
      goalTypeHint.classList.remove('warning', 'success');
      const profile = getProfile();
      const draftWeight = Number(weightInput && weightInput.value ? weightInput.value : NaN);
      const currentWeight = !Number.isNaN(draftWeight) && draftWeight > 0
        ? draftWeight
        : Number(profile.weight) || 0;
      const targetWeightValue = Number(targetWeight.value) || 0;
      if (!currentWeight || !targetWeightValue) {
        goalTypeHint.textContent = 'Set your current and goal weight to validate direction.';
        return;
      }
      const diff = targetWeightValue - currentWeight;
      const absDiff = Math.abs(diff);
      const maintainTolerance = 0.5;
      let message = '';
      let tone = '';
      if (selectedGoalType === 'maintain') {
        if (absDiff <= maintainTolerance) {
          message = 'Maintain goal aligns with your current weight.';
          tone = 'success';
        } else {
          message = 'Maintain goal expects your target within ±0.5 kg of current weight.';
          tone = 'warning';
        }
      } else if (selectedGoalType === 'loss') {
        if (diff < -0.05) {
          message = `Loss goal set to drop ${formatNumber(absDiff, 1)} kg.`;
          tone = 'success';
        } else {
          message = 'Loss goal requires a target below your current weight.';
          tone = 'warning';
        }
      } else if (selectedGoalType === 'gain') {
        if (diff > 0.05) {
          message = `Gain goal set to add ${formatNumber(absDiff, 1)} kg.`;
          tone = 'success';
        } else {
          message = 'Gain goal requires a target above your current weight.';
          tone = 'warning';
        }
      }
      goalTypeHint.textContent = message || 'Adjust your goal weight to validate direction.';
      if (tone) {
        goalTypeHint.classList.add(tone);
      }
    }

    function updatePaceUI() {
      if (!paceSelector || !paceSummary) return;
      const profile = getDraftProfile();
      const targetWeightValue = Number(targetWeight.value) || profile.weight;
      const paceData = computePaceData(profile, targetWeightValue);
      const direction = paceData.direction;

      paceSelector.querySelectorAll('button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.pace === selectedPace);
      });

      paceSummary.innerHTML = '';
      if (!paceData.maintenance) {
        paceSummary.innerHTML = '<div class="empty-state">Update your profile details to unlock calorie guidance.</div>';
        goalTimeline.value = 0;
        return;
      }

      Object.keys(paceRates).forEach(key => {
        const info = paceData[key];
        if (!info) return;
        const card = document.createElement('div');
        card.className = `pace-card${selectedPace === key ? ' active' : ''}`;
        card.dataset.pace = key;
        const weeksLabel = info.direction === 'maintain' ? 'Maintain' : `~${info.weeks} wk${info.weeks !== 1 ? 's' : ''}`;
        const rateLabel = info.rate.toFixed(2).replace(/\.00$/, '').replace(/0$/, '');
        let note;
        if (info.direction === 'maintain') {
          note = `Hold steady near ${formatNumber(info.calorieTarget)} kcal/day.`;
        } else {
          const changeWord = info.direction === 'loss' ? 'deficit' : 'surplus';
          note = `${formatNumber(info.dailyDelta)} kcal ${changeWord}/day · Target ${formatNumber(info.calorieTarget)} kcal/day · ~${rateLabel} kg/week`;
        }
        card.innerHTML = `
          <h4>${info.label}</h4>
          <div class="pace-value">${weeksLabel}</div>
          <div class="pace-note">${note}</div>
        `;
        paceSummary.appendChild(card);
      });

      const chosen = paceData[selectedPace];
      goalTimeline.value = chosen && chosen.direction !== 'maintain' ? chosen.weeks : 0;
    }

    function getMeals(date) {
      const parsed = safeGetStorage(mealKey(date), []);
      if (!Array.isArray(parsed)) return [];
      return parsed.map(normalizeMealEntry).filter(Boolean);
    }

    function saveMeals(date, meals) {
      safeSetStorage(mealKey(date), meals);
    }

    function getLoggedMealDates() {
      const dates = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('lifeos:meals:entries:')) {
          dates.push(key.slice('lifeos:meals:entries:'.length));
        }
      }
      dates.sort((a, b) => new Date(b) - new Date(a));
      return dates;
    }

    function getWater(date) {
      const raw = localStorage.getItem(waterKey(date));
      return raw ? Number(raw) : 0;
    }

    function saveWater(date, amount) {
      localStorage.setItem(waterKey(date), String(amount));
    }

    function getWeights() {
      const data = safeGetStorage(STORAGE_KEYS.weights, []);
      if (!Array.isArray(data)) return [];
      const normalized = data.map(normalizeWeightEntry).filter(Boolean);
      normalized.sort((a, b) => new Date(a.date) - new Date(b.date));
      return normalized;
    }

    function normalizeMealEntry(entry) {
      if (!entry || typeof entry !== 'object') return null;
      const calories = Number(entry.calories);
      const name = typeof entry.name === 'string' ? entry.name.trim() : '';
      if (!name || Number.isNaN(calories)) return null;
      return {
        id: entry.id || `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        name,
        calories: Math.max(0, calories),
        ingredients: typeof entry.ingredients === 'string' ? entry.ingredients : '',
        protein: Number(entry.protein) || 0,
        carbs: Number(entry.carbs) || 0,
        fat: Number(entry.fat) || 0,
        type: typeof entry.type === 'string' ? entry.type : inferMealType(entry.time),
        time: typeof entry.time === 'string' ? entry.time : currentTimeValue(),
        date: typeof entry.date === 'string' ? entry.date : dateInput.value
      };
    }

    function normalizeWeightEntry(entry) {
      if (!entry || typeof entry !== 'object') return null;
      const weight = Number(entry.weight);
      const date = typeof entry.date === 'string' ? entry.date : '';
      if (!date || !Number.isFinite(weight) || weight <= 0) return null;
      return { date, weight };
    }

    function saveWeights(entries) {
      safeSetStorage(STORAGE_KEYS.weights, entries);
    }

    function formatNumber(value, decimals = 0) {
      return Number(value || 0).toFixed(decimals);
    }

    function formatDateLabel(value) {
      if (!value) return '';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return '';
      return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
    }

    function formatSignedValue(value, decimals = 1, unit = '') {
      if (value === null || value === undefined) {
        return unit ? `0 ${unit}` : '0';
      }
      const abs = Math.abs(value);
      if (abs < (decimals ? Math.pow(10, -decimals) : 0.01)) {
        return unit ? `0 ${unit}` : '0';
      }
      const formatted = abs.toFixed(decimals);
      const sign = value > 0 ? '+' : '−';
      return unit ? `${sign}${formatted} ${unit}` : `${sign}${formatted}`;
    }

    function formatDaysToTarget(days) {
      if (!days || Number.isNaN(days) || days <= 0) return '—';
      if (days === 1) return '1 day';
      const weeks = days / 7;
      return weeks >= 1 ? `${days} days (~${weeks.toFixed(1)} wk)` : `${days} days`;
    }

    function formatProjectionPeriod(weeks) {
      if (!weeks || Number.isNaN(weeks) || weeks <= 0) return 'Timeline pending';
      const numericWeeks = Number(weeks);
      if (numericWeeks < 1.5) {
        const days = Math.max(1, Math.round(numericWeeks * 7));
        return `in ${days} day${days === 1 ? '' : 's'}`;
      }
      if (numericWeeks >= 8) {
        const months = Math.round((numericWeeks / 4.345) * 10) / 10;
        const decimals = months % 1 === 0 ? 0 : 1;
        const monthText = formatNumber(months, decimals);
        const plural = Math.abs(months - 1) < 0.05 ? '' : 's';
        return `in ~${monthText} month${plural}`;
      }
      const roundedWeeks = Math.round(numericWeeks);
      return `in ${roundedWeeks} week${roundedWeeks === 1 ? '' : 's'}`;
    }

    function calcBMI(weight, height) {
      if (!weight || !height) return null;
      const h = height / 100;
      if (!h) return null;
      return weight / (h * h);
    }

    function bmiStatus(bmi) {
      if (!bmi) return 'Add details to calculate BMI';
      if (bmi < 18.5) return 'Underweight';
      if (bmi < 25) return 'Optimal';
      if (bmi < 30) return 'Overweight';
      return 'Obese';
    }

    function updateBMI() {
      const profile = getProfile();
      const bmi = calcBMI(profile.weight, profile.height);
      if (bmi) {
        bmiValue.textContent = bmi.toFixed(1);
        bmiLabel.textContent = bmiStatus(bmi);
        const progress = Math.min(100, Math.max(0, ((bmi - 15) / (30 - 15)) * 100));
        bmiProgress.style.width = progress + '%';
      } else {
        bmiValue.textContent = '--';
        bmiLabel.textContent = 'Update profile for BMI';
        bmiProgress.style.width = '0%';
      }
    }

    function renderSummary() {
      const date = dateInput.value;
      const meals = getMeals(date);
      const targets = getTargets();
      let totalCalories = 0;
      let totalProtein = 0;
      let totalCarbs = 0;
      let totalFat = 0;
      meals.forEach(meal => {
        totalCalories += Number(meal.calories || 0);
        totalProtein += Number(meal.protein || 0);
        totalCarbs += Number(meal.carbs || 0);
        totalFat += Number(meal.fat || 0);
      });
      const water = getWater(date);
      summaryCards.innerHTML = '';
      if (macroHighlight) {
        macroHighlight.textContent = 'Click a nutrient card to open detailed insights.';
        macroHighlight.classList.remove('active');
        if (macroSection) {
          macroHighlight.style.display = macroSection.classList.contains('collapsed') ? 'none' : '';
        }
      }

      const summaryData = [
        { icon: 'fa-fire', label: 'Calories', value: totalCalories, unit: 'kcal', target: targets.calories, key: 'calories' },
        { icon: 'fa-drumstick-bite', label: 'Protein', value: totalProtein, unit: 'g', target: targets.protein, key: 'protein' },
        { icon: 'fa-bread-slice', label: 'Carbs', value: totalCarbs, unit: 'g', target: targets.carbs, key: 'carbs' },
        { icon: 'fa-bacon', label: 'Fat', value: totalFat, unit: 'g', target: targets.fat, key: 'fat' }
      ];

      const celebrates = [];
      const warnings = [];

      latestSummary = {
        calories: totalCalories,
        protein: totalProtein,
        carbs: totalCarbs,
        fat: totalFat,
        water
      };

      summaryData.forEach(item => {
        const percent = item.target ? Math.min(100, (item.value / item.target) * 100) : 0;
        const card = document.createElement('div');
        card.className = 'summary-card';
        card.dataset.metric = item.key;
        card.setAttribute('role', 'button');
        card.setAttribute('tabindex', '0');
        card.setAttribute('aria-label', `Open ${item.label.toLowerCase()} insight`);
        card.innerHTML = `
          <div class="summary-icon"><i class="fa-solid ${item.icon}"></i></div>
          <div class="summary-details">
            <div class="value">${formatNumber(item.value)} ${item.unit}</div>
            <div class="label">${item.label} · ${comparisonLabel(item.value, item.target)}</div>
            <div class="progress-track"><div class="progress-fill" style="width:${percent}%;"></div></div>
          </div>
        `;
        summaryCards.appendChild(card);

        if (item.target > 0 && ['calories', 'protein', 'carbs', 'fat'].includes(item.key)) {
          const ratio = item.value / item.target;
          if (ratio >= 0.95 && ratio <= 1.05) {
            celebrates.push(item.label);
          } else if (ratio > 1.05) {
            warnings.push(`${item.label} overshot by ${formatNumber(item.value - item.target)} ${item.unit}`);
          }
        }
      });

      waterTotal.textContent = formatNumber(water);
      const waterPercent = targets.water ? Math.min(100, (water / targets.water) * 100) : 0;
      waterProgress.style.width = waterPercent + '%';
      if (waterTargetLabel) {
        waterTargetLabel.textContent = targets.water ? formatNumber(targets.water) : '—';
      }

      showCelebrations(celebrates);
      showWarnings(warnings);
      updateAnalytics(meals);
      updateHistory();
      refreshWeightWidget();
    }
    function comparisonLabel(current, target) {
      if (!target || target <= 0) return 'No target set';
      const diff = current - target;
      const tolerance = target * 0.05;
      if (Math.abs(diff) <= tolerance) return 'Within 5% of goal';
      return diff > 0 ? `Over by ${formatNumber(diff)}` : `Under by ${formatNumber(Math.abs(diff))}`;
    }

    function showCelebrations(items) {
      if (items.length) {
        const text = items.length === 1 ? items[0] : `${items.slice(0, -1).join(', ')} and ${items.slice(-1)}`;
        summaryCelebration.textContent = `🎉 Congratulations! You nailed your ${text} target${items.length > 1 ? 's' : ''}.`;
        summaryCelebration.classList.add('show');
      } else {
        summaryCelebration.classList.remove('show');
        summaryCelebration.textContent = '';
      }
    }

    function showWarnings(messages) {
      if (messages.length) {
        summaryWarning.innerHTML = `<i class="fa-solid fa-triangle-exclamation"></i> ${messages.join(' · ')}`;
        summaryWarning.classList.add('show');
      } else {
        summaryWarning.classList.remove('show');
        summaryWarning.textContent = '';
      }
    }

    function openMetricInsight(metric) {
      if (!calorieModal || !calorieSummary || !calorieModalTitle) return;
      const metricConfig = {
        calories: {
          label: 'Calories',
          icon: 'fa-fire',
          unit: 'kcal',
          property: 'calories',
          targetKey: 'calories',
          decimals: 0,
          title: 'Daily Calorie Insight',
          emptyMessage: 'Log meals with calorie values to unlock this insight.'
        },
        protein: {
          label: 'Protein',
          icon: 'fa-drumstick-bite',
          unit: 'g',
          property: 'protein',
          targetKey: 'protein',
          decimals: 1,
          title: 'Protein Insight',
          emptyMessage: 'No protein tracked for this day. Enable "Track macros" when logging meals.'
        },
        carbs: {
          label: 'Carbs',
          icon: 'fa-bread-slice',
          unit: 'g',
          property: 'carbs',
          targetKey: 'carbs',
          decimals: 1,
          title: 'Carbohydrate Insight',
          emptyMessage: 'No carbs tracked for this day. Enable "Track macros" when logging meals.'
        },
        fat: {
          label: 'Fat',
          icon: 'fa-bacon',
          unit: 'g',
          property: 'fat',
          targetKey: 'fat',
          decimals: 1,
          title: 'Fat Insight',
          emptyMessage: 'No fat tracked for this day. Enable "Track macros" when logging meals.'
        }
      };

      const config = metricConfig[metric];
      if (!config) {
        if (macroHighlight) {
          macroHighlight.textContent = 'Insights are available for calories, protein, carbs, and fat.';
          macroHighlight.classList.remove('active');
        }
        return;
      }

      const date = dateInput.value;
      const meals = getMeals(date);
      const targets = getTargets();
      const total = meals.reduce((sum, meal) => sum + Number(meal[config.property] || 0), 0);
      const target = Number(targets[config.targetKey] || 0);

      calorieModalTitle.innerHTML = `<i class="fa-solid ${config.icon}"></i> ${config.title}`;

      if (!meals.length) {
        calorieSummary.innerHTML = '<div class="empty-state">No meals logged yet for this day.</div>';
        toggleModal(calorieModal, true);
        return;
      }

      const contributions = meals
        .map(meal => ({ meal, value: Number(meal[config.property] || 0) }))
        .filter(item => item.value > 0)
        .sort((a, b) => b.value - a.value);

      let statusLabel = target ? 'On target' : 'No target set';
      let statusClass = '';
      if (target) {
        const diff = total - target;
        const tolerance = Math.max(1, target * 0.02);
        if (Math.abs(diff) <= tolerance) {
          statusLabel = 'Within range';
        } else if (diff > 0) {
          statusLabel = `Over by ${formatNumber(Math.abs(diff), config.decimals)} ${config.unit}`;
          statusClass = 'diff-surplus';
        } else {
          statusLabel = `Under by ${formatNumber(Math.abs(diff), config.decimals)} ${config.unit}`;
          statusClass = 'diff-deficit';
        }
      }

      const statsHtml = `
        <div class="stats-grid">
          <div class="stat-card">
            <span class="label">Logged</span>
            <span class="value">${formatNumber(total, config.decimals)} ${config.unit}</span>
          </div>
          <div class="stat-card">
            <span class="label">Target</span>
            <span class="value">${target ? `${formatNumber(target, config.decimals)} ${config.unit}` : '—'}</span>
          </div>
          <div class="stat-card ${statusClass}">
            <span class="label">Status</span>
            <span class="value">${statusLabel}</span>
          </div>
        </div>
      `;

      let topContributorHtml = '';
      if (contributions.length) {
        const leader = contributions[0];
        const share = total > 0 ? (leader.value / total) * 100 : 0;
        const shareLabel = share ? share.toFixed(1).replace(/\.0$/, '') : '0';
        const descriptor = formatMealDescriptor(leader.meal);
        const mealTime = formatMealTime(normaliseTime(leader.meal.time || '', '12:00'));
        const typeLabel = formatMealTypeLabel(resolveMealType(leader.meal));
        const detailParts = [];
        if (typeLabel) detailParts.push(typeLabel);
        if (mealTime && mealTime !== '--:--') detailParts.push(mealTime);
        const detailText = detailParts.length ? ` · ${escapeHtml(detailParts.join(' · '))}` : '';
        topContributorHtml = `
          <div class="top-contributor">
            <h4><i class="fa-solid fa-crown"></i> Top contributor</h4>
            <p><strong>${descriptor}</strong>${detailText}</p>
            <p>${formatNumber(leader.value, config.decimals)} ${config.unit}${share ? ` · ${shareLabel}% of total` : ''}</p>
          </div>
        `;
      } else {
        topContributorHtml = `
          <div class="top-contributor">
            <h4><i class="fa-solid fa-circle-info"></i> Top contributor</h4>
            <p>${config.emptyMessage}</p>
          </div>
        `;
      }

      let metabolicHtml = '';
      if (metric === 'calories') {
        const profile = getProfile();
        const bmr = Math.round(calculateBMR(profile));
        const tdee = Math.round(calculateTDEE(profile));
        const diff = tdee ? total - tdee : 0;
        const weeklyDelta = tdee ? (diff * 7) / KCAL_PER_KG : 0;
        let kgText = Math.abs(weeklyDelta).toFixed(2).replace(/\.00$/, '').replace(/0$/, '');
        if (!kgText) kgText = '0';
        let note;
        if (!tdee) {
          note = 'Update your profile details to unlock metabolic comparisons.';
        } else if (diff === 0) {
          note = 'You are perfectly aligned with your maintenance calories today.';
        } else if (diff > 0) {
          note = `Estimated surplus of ${formatNumber(diff)} kcal (~${kgText} kg/week).`;
        } else {
          note = `Estimated deficit of ${formatNumber(Math.abs(diff))} kcal (~${kgText} kg/week).`;
        }
        const diffLabel = !tdee
          ? '—'
          : diff > 0
            ? `+${formatNumber(Math.abs(diff))} kcal`
            : diff < 0
              ? `-${formatNumber(Math.abs(diff))} kcal`
              : '0 kcal';
        metabolicHtml = `
          <div class="info-block">
            <h4><i class="fa-solid fa-fire-flame-curved"></i> Metabolic check-in</h4>
            <p><strong>BMR:</strong> ${bmr ? formatNumber(bmr) : '—'} kcal · <strong>TDEE:</strong> ${tdee ? formatNumber(tdee) : '—'} kcal</p>
            <p><strong>Net difference:</strong> ${diffLabel}</p>
            <p>${note}</p>
          </div>
        `;
      }

      let tableHtml = '';
      if (contributions.length) {
        const rows = contributions.map(item => {
          const share = total > 0 ? (item.value / total) * 100 : 0;
          const shareLabel = share ? share.toFixed(1).replace(/\.0$/, '') : '0';
          const mealTime = formatMealTime(normaliseTime(item.meal.time || '', '12:00'));
          const typeLabel = formatMealTypeLabel(resolveMealType(item.meal));
          const metaParts = [];
          if (typeLabel) metaParts.push(typeLabel);
          if (mealTime && mealTime !== '--:--') metaParts.push(mealTime);
          const meta = metaParts.length ? `<span class="subtext">${escapeHtml(metaParts.join(' · '))}</span>` : '';
          return `
            <tr>
              <td>${formatMealDescriptor(item.meal)}${meta}</td>
              <td>${formatNumber(item.value, config.decimals)} ${config.unit}</td>
              <td>${shareLabel}%</td>
            </tr>
          `;
        }).join('');
        tableHtml = `
          <div>
            <table>
              <thead>
                <tr>
                  <th>Meal</th>
                  <th>${config.label}</th>
                  <th>Share</th>
                </tr>
              </thead>
              <tbody>${rows}</tbody>
            </table>
          </div>
        `;
      } else {
        tableHtml = `<div class="empty-state">${config.emptyMessage}</div>`;
      }

      calorieSummary.innerHTML = `${statsHtml}${topContributorHtml}${metabolicHtml}${tableHtml}`;
      toggleModal(calorieModal, true);
    }

    function renderMeals() {
      if (!mealSections) return;
      const wasOpen = mealLogToggle ? mealLogToggle.open : true;
      const date = dateInput.value;
      const meals = getMeals(date);
      mealSections.innerHTML = '';
      const totalCalories = meals.reduce((sum, meal) => sum + Number(meal.calories || 0), 0);
      if (mealLogSummary) {
        mealLogSummary.textContent = meals.length
          ? `${meals.length} meal${meals.length !== 1 ? 's' : ''} · ${formatNumber(totalCalories)} kcal`
          : 'Nothing logged';
      }

      if (!meals.length) {
        const empty = document.createElement('div');
        empty.className = 'meal-type-empty';
        empty.textContent = 'No meals logged yet';
        mealSections.appendChild(empty);
        if (mealLogToggle) mealLogToggle.open = true;
        return;
      }

      const grouped = {};
      meals.forEach((meal, index) => {
        const type = resolveMealType(meal);
        if (!grouped[type]) grouped[type] = [];
        grouped[type].push({ meal, index });
      });

      mealTypes.forEach(({ key, label }) => {
        const entries = grouped[key] || [];
        if (!entries.length) return;
        entries.sort((a, b) => (a.meal.time || '').localeCompare(b.meal.time || ''));
        const section = document.createElement('details');
        section.className = 'meal-type-block';
        section.open = true;
        const totalCalories = entries.reduce((sum, entry) => sum + Number(entry.meal.calories || 0), 0);
        const summary = document.createElement('summary');
        summary.innerHTML = `
          <span>${label}</span>
          <span class="meal-type-info">${entries.length} item${entries.length !== 1 ? 's' : ''} · ${formatNumber(totalCalories)} kcal</span>
        `;
        section.appendChild(summary);

        const table = document.createElement('table');
        table.className = 'meal-table';
        table.innerHTML = `
          <thead>
            <tr>
              <th>Time</th>
              <th>Meal</th>
              <th>Ingredients</th>
              <th>Calories</th>
              <th>Protein</th>
              <th>Carbs</th>
              <th>Fat</th>
              <th></th>
            </tr>
          </thead>
          <tbody></tbody>
        `;

        const tbody = table.querySelector('tbody');
        entries.forEach(({ meal, index }) => {
          const row = document.createElement('tr');
          const ingredients = meal.ingredients
            ? escapeHtml(meal.ingredients).replace(/\n/g, '<br>')
            : '—';
          row.innerHTML = `
            <td>${formatMealTime(meal.time)}</td>
            <td>${escapeHtml(meal.name || '')}</td>
            <td>${ingredients}</td>
            <td>${formatNumber(meal.calories)}</td>
            <td>${meal.protein ? formatNumber(meal.protein) : '—'}</td>
            <td>${meal.carbs ? formatNumber(meal.carbs) : '—'}</td>
            <td>${meal.fat ? formatNumber(meal.fat) : '—'}</td>
            <td><button class="secondary" data-delete="${index}"><i class="fa-solid fa-trash"></i></button></td>
          `;
          tbody.appendChild(row);
        });

        section.appendChild(table);
        mealSections.appendChild(section);
      });

      if (mealLogToggle) mealLogToggle.open = wasOpen;
    }

    function formatMealDescriptor(meal) {
      if (!meal) return 'Meal';
      const name = meal.name ? meal.name.trim() : '';
      if (name) return escapeHtml(name);
      return escapeHtml(formatMealTypeLabel(resolveMealType(meal)));
    }

    if (mealSections) {
      mealSections.addEventListener('click', event => {
        const button = event.target.closest('button[data-delete]');
        if (!button) return;
        const index = Number(button.dataset.delete);
        const date = dateInput.value;
        const meals = getMeals(date);
        if (Number.isNaN(index) || index < 0 || index >= meals.length) return;
        meals.splice(index, 1);
        saveMeals(date, meals);
        renderMeals();
        renderSummary();
      });
    }

    mealForm.addEventListener('submit', event => {
      event.preventDefault();
      const timeValue = normaliseTime(mealTimeInput ? mealTimeInput.value : '');
      const meal = {
        name: document.getElementById('mealName').value.trim() || 'Meal',
        ingredients: document.getElementById('ingredients').value.trim(),
        calories: Number(document.getElementById('calories').value) || 0,
        time: timeValue,
        type: determineMealTypeForTime(timeValue),
        protein: 0,
        carbs: 0,
        fat: 0
      };
      if (showMacros.checked) {
        meal.protein = Number(document.getElementById('protein').value) || 0;
        meal.carbs = Number(document.getElementById('carbs').value) || 0;
        meal.fat = Number(document.getElementById('fat').value) || 0;
      }
      const date = dateInput.value;
      const meals = getMeals(date);
      meals.push(meal);
      saveMeals(date, meals);
      mealForm.reset();
      setDefaultMealTime();
      macroFields.style.display = 'none';
      renderMeals();
      renderSummary();
    });

    showMacros.addEventListener('change', () => {
      macroFields.style.display = showMacros.checked ? 'grid' : 'none';
    });

    function addWater(amount) {
      const date = dateInput.value;
      const current = getWater(date);
      const addition = amount !== undefined ? amount : Number(waterInput.value) || 0;
      const total = current + addition;
      saveWater(date, total);
      waterInput.value = '';
      renderSummary();
    }

    addWaterBtn.addEventListener('click', () => addWater());
    quickWaterBtn.addEventListener('click', () => addWater(250));

    function renderPresets() {
      const presets = getPresets();
      presetButtonsContainer.innerHTML = '';
      if (!presets.length) {
        noPresets.style.display = 'block';
        return;
      }
      noPresets.style.display = 'none';
      presets.forEach(preset => {
        const btn = document.createElement('button');
        btn.className = 'secondary';
        btn.innerHTML = `
          <span class="preset-name">${preset.name}</span>
          <span class="preset-cal">${formatNumber(preset.calories)} kcal${preset.protein ? ` · ${formatNumber(preset.protein)}g P` : ''}</span>
        `;
        btn.addEventListener('click', () => {
          const timeValue = currentTimeValue();
          const meal = {
            name: preset.name,
            ingredients: preset.ingredients || '',
            calories: Number(preset.calories) || 0,
            time: timeValue,
            type: determineMealTypeForTime(timeValue),
            protein: Number(preset.protein) || 0,
            carbs: Number(preset.carbs) || 0,
            fat: Number(preset.fat) || 0
          };
          const date = dateInput.value;
          const meals = getMeals(date);
          meals.push(meal);
          saveMeals(date, meals);
          renderMeals();
          renderSummary();
        });
        presetButtonsContainer.appendChild(btn);
      });
    }

    function updateHistory() {
      const dates = getLoggedMealDates();
      historyList.innerHTML = '';
      if (!dates.length) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No history yet';
        historyList.appendChild(empty);
        return;
      }
      const MAX_VISIBLE_HISTORY = 7;
      const visibleDates = dates.slice(0, MAX_VISIBLE_HISTORY);
      visibleDates.forEach(date => {
        const meals = getMeals(date);
        const calories = meals.reduce((sum, meal) => sum + Number(meal.calories || 0), 0);
        const entry = document.createElement('div');
        entry.className = 'history-item';
        entry.innerHTML = `<span>${date}</span><span>${formatNumber(calories)} kcal</span>`;
        entry.addEventListener('click', () => {
          dateInput.value = date;
          renderMeals();
          renderSummary();
        });
        historyList.appendChild(entry);
      });

      if (dates.length > MAX_VISIBLE_HISTORY) {
        const more = document.createElement('div');
        more.className = 'history-more-note';
        more.textContent = `+${dates.length - MAX_VISIBLE_HISTORY} more day${dates.length - MAX_VISIBLE_HISTORY === 1 ? '' : 's'} in Manage entries`;
        historyList.appendChild(more);
      }

      if (historyModal && historyModal.classList.contains('open')) {
        populateHistoryManager(true);
      }
    }

    function populateHistoryManager(preserveSelection = false) {
      if (!historyDateInput || !historyEntries) return;
      const dates = getLoggedMealDates();
      const previous = preserveSelection ? historyDateInput.value : '';
      if (!dates.length) {
        historyDateInput.disabled = true;
        historyDateInput.value = '';
        historyDateInput.removeAttribute('min');
        historyDateInput.removeAttribute('max');
        historyEntries.innerHTML = '<div class="history-edit-empty">Log meals to edit them.</div>';
        return;
      }

      historyDateInput.disabled = false;
      historyDateInput.min = dates[dates.length - 1];
      historyDateInput.max = dates[0];
      const targetDate = preserveSelection && previous && dates.includes(previous) ? previous : dates[0];
      historyDateInput.value = targetDate;
      renderHistoryEditor(targetDate);
    }

    function renderHistoryEditor(date) {
      if (!historyEntries) return;
      historyEntries.innerHTML = '';
      if (!date) {
        historyEntries.innerHTML = '<div class="history-edit-empty">No logged meals yet.</div>';
        return;
      }
      const meals = getMeals(date);
      if (!meals.length) {
        historyEntries.innerHTML = '<div class="history-edit-empty">No meals recorded for this day.</div>';
        return;
      }

      meals.forEach((meal, index) => {
        const row = document.createElement('div');
        row.className = 'history-edit-row';
        const timeValue = normaliseTime(meal.time || '', '12:00');
        const typeValue = resolveMealType(meal);
        row.innerHTML = `
          <div class="history-edit-grid">
            <label>Time<input type="time" step="60" value="${timeValue}" data-field="time" data-index="${index}"></label>
            <label>Type<select data-field="type" data-index="${index}">${mealTypes.map(option => `<option value="${option.key}"${option.key === typeValue ? ' selected' : ''}>${option.label}</option>`).join('')}</select></label>
            <label>Meal<input type="text" value="${escapeHtml(meal.name || '')}" data-field="name" data-index="${index}"></label>
            <label>Calories<input type="number" min="0" step="1" value="${meal.calories !== undefined ? meal.calories : ''}" data-field="calories" data-index="${index}"></label>
            <label>Protein<input type="number" min="0" step="1" value="${meal.protein !== undefined ? meal.protein : ''}" data-field="protein" data-index="${index}"></label>
            <label>Carbs<input type="number" min="0" step="1" value="${meal.carbs !== undefined ? meal.carbs : ''}" data-field="carbs" data-index="${index}"></label>
            <label>Fat<input type="number" min="0" step="1" value="${meal.fat !== undefined ? meal.fat : ''}" data-field="fat" data-index="${index}"></label>
          </div>
          <div class="history-edit-grid">
            <label>Ingredients<textarea data-field="ingredients" data-index="${index}">${escapeHtml(meal.ingredients || '')}</textarea></label>
          </div>
          <div class="history-edit-actions">
            <button class="secondary" data-history-action="delete" data-index="${index}"><i class="fa-solid fa-trash"></i> Delete</button>
            <button class="primary" data-history-action="save" data-index="${index}"><i class="fa-solid fa-floppy-disk"></i> Save</button>
          </div>
        `;
        historyEntries.appendChild(row);
      });
    }

    function refreshCurrentDayIfMatched(date) {
      if (dateInput.value === date) {
        renderMeals();
        renderSummary();
      }
    }

    if (openHistoryManagerBtn) {
      openHistoryManagerBtn.addEventListener('click', () => {
        populateHistoryManager();
        toggleModal(historyModal, true);
      });
    }

    if (historyDateInput) {
      historyDateInput.addEventListener('change', () => {
        renderHistoryEditor(historyDateInput.value);
      });
    }

    if (historyEntries) {
      historyEntries.addEventListener('click', event => {
        const actionBtn = event.target.closest('[data-history-action]');
        if (!actionBtn) return;
        const action = actionBtn.dataset.historyAction;
        const index = Number(actionBtn.dataset.index);
        const selectedDate = historyDateInput ? historyDateInput.value : '';
        if (!selectedDate) return;
        const meals = getMeals(selectedDate);
        if (Number.isNaN(index) || index < 0 || index >= meals.length) return;

        if (action === 'delete') {
          meals.splice(index, 1);
          if (meals.length) {
            saveMeals(selectedDate, meals);
          } else {
            localStorage.removeItem(mealKey(selectedDate));
          }
          updateHistory();
          refreshCurrentDayIfMatched(selectedDate);
          return;
        }

        if (action === 'save') {
          const row = actionBtn.closest('.history-edit-row');
          if (!row) return;
          const updated = { ...meals[index] };
          const timeInput = row.querySelector('[data-field="time"]');
          const typeInput = row.querySelector('[data-field="type"]');
          const nameInput = row.querySelector('[data-field="name"]');
          const ingredientsInput = row.querySelector('[data-field="ingredients"]');
          const caloriesInput = row.querySelector('[data-field="calories"]');
          const proteinInput = row.querySelector('[data-field="protein"]');
          const carbsInput = row.querySelector('[data-field="carbs"]');
          const fatInput = row.querySelector('[data-field="fat"]');

          updated.time = normaliseTime(timeInput ? timeInput.value : updated.time, updated.time || '12:00');
          updated.type = typeInput ? typeInput.value : resolveMealType(updated);
          updated.name = nameInput ? nameInput.value.trim() || 'Meal' : updated.name;
          updated.ingredients = ingredientsInput ? ingredientsInput.value.trim() : updated.ingredients;
          updated.calories = caloriesInput && caloriesInput.value !== '' ? Number(caloriesInput.value) : 0;
          updated.protein = proteinInput && proteinInput.value !== '' ? Number(proteinInput.value) : 0;
          updated.carbs = carbsInput && carbsInput.value !== '' ? Number(carbsInput.value) : 0;
          updated.fat = fatInput && fatInput.value !== '' ? Number(fatInput.value) : 0;

          meals[index] = updated;
          saveMeals(selectedDate, meals);

          const originalHtml = actionBtn.innerHTML;
          actionBtn.innerHTML = '<i class="fa-solid fa-circle-check"></i> Saved';
          actionBtn.disabled = true;
          setTimeout(() => {
            actionBtn.disabled = false;
            actionBtn.innerHTML = originalHtml;
          }, 1200);

          updateHistory();
          refreshCurrentDayIfMatched(selectedDate);
        }
      });
    }

    function updateAnalytics(currentMeals = []) {
      const labels = [];
      const caloriesData = [];
      const waterData = [];
      const loggedCalories = [];
      const referenceDate = dateInput.value ? new Date(dateInput.value) : new Date();
      const targets = getTargets();
      const profile = getProfile();
      for (let i = 6; i >= 0; i--) {
        const day = new Date(referenceDate);
        day.setDate(day.getDate() - i);
        const dateStr = day.toISOString().split('T')[0];
        labels.push(day.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }));
        const meals = getMeals(dateStr);
        const caloriesForDay = meals.reduce((sum, meal) => sum + Number(meal.calories || 0), 0);
        caloriesData.push(caloriesForDay);
        if (caloriesForDay > 0) {
          loggedCalories.push(caloriesForDay);
        }
        waterData.push(getWater(dateStr));
      }

      const totalLoggedCalories = loggedCalories.reduce((sum, value) => sum + value, 0);
      const averageLoggedCalories = loggedCalories.length ? totalLoggedCalories / loggedCalories.length : 0;
      const maintenanceCalories = Math.round(calculateTDEE(profile)) || 0;
      const averageDailyDelta = loggedCalories.length && maintenanceCalories
        ? averageLoggedCalories - maintenanceCalories
        : 0;
      const weeklyDeltaKg = loggedCalories.length && averageDailyDelta
        ? (averageDailyDelta * 7) / KCAL_PER_KG
        : 0;

      analyticsCache.calories = {
        labels: [...labels],
        data: [...caloriesData],
        target: Number(targets.calories) || 0,
        loggedAverage: averageLoggedCalories,
        maintenance: maintenanceCalories,
        averageDelta: averageDailyDelta,
        weeklyDeltaKg,
        loggedDays: loggedCalories.length
      };

      const calorieCanvas = document.getElementById('calorieChart');
      if (calorieCanvas) {
        if (calorieChart) calorieChart.destroy();
        calorieChart = new Chart(calorieCanvas.getContext('2d'), {
          type: 'line',
          data: {
            labels,
            datasets: [
              {
                label: 'Calories',
                data: caloriesData,
                fill: true,
                borderColor: 'rgba(21,197,163,0.9)',
                backgroundColor: 'rgba(21,197,163,0.18)',
                tension: 0.35,
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          },
          options: getChartOptions('Calories (7 days)')
        });
      }

      const totalProtein = currentMeals.reduce((sum, meal) => sum + Number(meal.protein || 0), 0);
      const totalCarbs = currentMeals.reduce((sum, meal) => sum + Number(meal.carbs || 0), 0);
      const totalFat = currentMeals.reduce((sum, meal) => sum + Number(meal.fat || 0), 0);

      analyticsCache.macros = {
        protein: totalProtein,
        carbs: totalCarbs,
        fat: totalFat,
        total: totalProtein + totalCarbs + totalFat,
        targets: {
          protein: Number(targets.protein) || 0,
          carbs: Number(targets.carbs) || 0,
          fat: Number(targets.fat) || 0
        }
      };

      const macroCanvas = document.getElementById('macroChart');
      if (macroCanvas) {
        if (macroChart) macroChart.destroy();
        macroChart = new Chart(macroCanvas.getContext('2d'), {
          type: 'doughnut',
          data: {
            labels: ['Protein', 'Carbs', 'Fat'],
            datasets: [{
              data: [totalProtein, totalCarbs, totalFat],
              backgroundColor: ['#5c7cfa', '#ffb347', '#f75f78'],
              borderWidth: 0,
              hoverOffset: 6
            }]
          },
          options: {
            plugins: {
              legend: {
                labels: {
                  color: '#d9deff'
                }
              }
            }
          }
        });
      }

      const activeDate = dateInput.value || new Date().toISOString().split('T')[0];
      const todayWater = getWater(activeDate);
      const averageWater = waterData.length
        ? waterData.reduce((sum, value) => sum + Number(value || 0), 0) / waterData.length
        : 0;

      analyticsCache.water = {
        labels: [...labels],
        data: [...waterData],
        target: Number(targets.water) || 0,
        today: todayWater,
        average: averageWater
      };

      const waterCanvas = document.getElementById('waterChart');
      if (waterCanvas) {
        if (waterChart) waterChart.destroy();
        waterChart = new Chart(waterCanvas.getContext('2d'), {
          type: 'bar',
          data: {
            labels,
            datasets: [
              {
                label: 'Water (ml)',
                data: waterData,
                backgroundColor: 'rgba(48, 220, 188, 0.45)',
                borderColor: 'rgba(48, 220, 188, 0.9)',
                borderWidth: 1,
                borderRadius: 8,
                borderSkipped: false
              }
            ]
          },
          options: getChartOptions('Water intake (7 days)')
        });
      }

      if (waterSummary) {
        const parts = [`Today: ${formatNumber(todayWater)} ml`];
        if (targets.water) {
          parts.push(`Target ${formatNumber(targets.water)} ml`);
        }
        parts.push(`7-day avg ${formatNumber(Math.round(averageWater))} ml`);
        waterSummary.textContent = parts.join(' · ');
      }

      const typeTotals = { breakfast: 0, lunch: 0, snack: 0, dinner: 0 };
      currentMeals.forEach(meal => {
        const type = resolveMealType(meal);
        if (!(type in typeTotals)) typeTotals[type] = 0;
        typeTotals[type] += Number(meal.calories || 0);
      });
      const otherCalories = (typeTotals.breakfast || 0) + (typeTotals.snack || 0);
      const totalSplitCalories = Object.values(typeTotals).reduce((sum, value) => sum + value, 0);
      const mealSplitData = [typeTotals.lunch || 0, typeTotals.dinner || 0, otherCalories];
      const averages = calculateAverageMealTimes();

      analyticsCache.mealSplit = {
        totals: { ...typeTotals },
        combined: { other: otherCalories },
        totalCalories: totalSplitCalories,
        averages
      };

      if (mealSplitInfo) {
        const timeEntries = mealTypes
          .map(({ key, label }) => (averages[key] ? `${label} ~ ${averages[key]}` : null))
          .filter(Boolean);
        mealSplitInfo.textContent = timeEntries.length
          ? `Average meal timing · ${timeEntries.join(' · ')}`
          : 'Add meal times to unlock meal insights.';
      }

      const mealSplitCanvas = document.getElementById('mealSplitChart');
      if (mealSplitCanvas) {
        if (mealSplitChart) mealSplitChart.destroy();
        mealSplitChart = new Chart(mealSplitCanvas.getContext('2d'), {
          type: 'doughnut',
          data: {
            labels: ['Lunch', 'Dinner', 'Breakfast/Snacks'],
            datasets: [{
              data: mealSplitData,
              backgroundColor: ['#5c7cfa', '#f75f78', '#ffb347'],
              borderWidth: 0,
              hoverOffset: 6
            }]
          },
          options: {
            plugins: {
              legend: {
                labels: {
                  color: '#d9deff'
                }
              }
            }
          }
        });
      }

      const weightAnalytics = computeWeightAnalytics();
      analyticsCache.weight = weightAnalytics;
      updateWeightSummary(weightAnalytics);
      renderWeightProjectionChart(weightAnalytics);
    }

    function minutesToDisplay(minutes) {
      if (minutes === null || minutes === undefined || Number.isNaN(minutes)) return null;
      const total = Math.round(minutes);
      const hours = Math.floor(total / 60) % 24;
      const mins = total % 60;
      const date = new Date();
      date.setHours(hours);
      date.setMinutes(mins);
      date.setSeconds(0);
      return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
    }

    function calculateAverageMealTimes() {
      const totals = {};
      mealTypes.forEach(({ key }) => {
        totals[key] = { minutes: 0, count: 0 };
      });
      const dates = getLoggedMealDates();
      dates.forEach(date => {
        const meals = getMeals(date);
        meals.forEach(meal => {
          const type = resolveMealType(meal);
          if (!totals[type]) totals[type] = { minutes: 0, count: 0 };
          const minutes = timeStringToMinutes(normaliseTime(meal.time, '12:00'));
          if (minutes !== null) {
            totals[type].minutes += minutes;
            totals[type].count += 1;
          }
        });
      });
      const averages = {};
      Object.keys(totals).forEach(key => {
        const bucket = totals[key];
        if (bucket.count) {
          averages[key] = minutesToDisplay(bucket.minutes / bucket.count);
        }
      });
      return averages;
    }

    function computeWeightAnalytics() {
      const entries = getWeights();
      const targets = getTargets();
      const profile = getProfile();
      const validEntries = entries.filter(entry => Number(entry.weight) > 0);
      const hasRealEntries = validEntries.length > 0;
      const paceKey = targets.goalPace || 'normal';
      const paceMeta = paceRates[paceKey] || null;
      const rawTargetWeight = Number(targets.weightTarget);
      const hasGoal = rawTargetWeight > 0;
      const targetWeight = hasGoal ? rawTargetWeight : 0;
      const timelineWeeks = Number(targets.goalTimeline) || 0;
      const calorieInsights = analyticsCache.calories || {};
      const averageLoggedCalories = Number(calorieInsights.loggedAverage) || 0;
      const maintenanceCalories = Number(calorieInsights.maintenance) || Math.round(calculateTDEE(profile)) || 0;
      const averageDailyDelta = Number(calorieInsights.averageDelta) || (maintenanceCalories ? averageLoggedCalories - maintenanceCalories : 0);
      let weeklyTrendKg = Number(calorieInsights.weeklyDeltaKg) || 0;
      const loggedCalorieDays = Number(calorieInsights.loggedDays) || 0;

      let historyEntries = validEntries.slice();
      let usingSyntheticHistory = false;

      if (!historyEntries.length) {
        const baseWeight = Number(profile.weight) || targetWeight || 0;
        const baseDate = new Date().toISOString().split('T')[0];
        if (baseWeight > 0) {
          historyEntries = generateSyntheticHistory(baseWeight, baseDate, targetWeight, paceMeta);
          usingSyntheticHistory = historyEntries.length > 0;
        }
      }

      if (!historyEntries.length && profile.weight) {
        const today = new Date().toISOString().split('T')[0];
        historyEntries = [{ date: today, weight: Number(profile.weight) }];
      }

      historyEntries = historyEntries
        .filter(entry => Number(entry.weight) > 0 && entry.date)
        .sort((a, b) => new Date(a.date) - new Date(b.date));

      const startEntry = historyEntries[0] || null;
      const latestEntry = historyEntries[historyEntries.length - 1] || null;

      let startWeight = startEntry ? Number(startEntry.weight || 0) : 0;
      let startDate = startEntry ? startEntry.date : null;
      let latestWeight = latestEntry ? Number(latestEntry.weight || 0) : 0;
      let latestDate = latestEntry ? latestEntry.date : null;

      if (!latestWeight && profile.weight) {
        latestWeight = Number(profile.weight);
      }
      if (!latestDate && historyEntries.length === 0) {
        latestDate = new Date().toISOString().split('T')[0];
      }
      if (!startWeight && latestWeight) {
        startWeight = latestWeight;
      }
      if (!startDate && latestDate) {
        startDate = latestDate;
      }

      const labels = historyEntries.length
        ? historyEntries.map(entry => {
            const parts = entry.date.split('-').map(Number);
            if (parts.length === 3 && parts.every(num => !Number.isNaN(num))) {
              return new Date(parts[0], parts[1] - 1, parts[2]).toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
            }
            const parsed = new Date(entry.date);
            return Number.isNaN(parsed.getTime())
              ? entry.date
              : parsed.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
          })
        : [];
      const data = historyEntries.length
        ? historyEntries.map(entry => Number(entry.weight || 0))
        : latestWeight
          ? [latestWeight]
          : [];

      const totalChange = (latestWeight || 0) - (startWeight || 0);
      const totalChangeAbs = Math.abs(totalChange);

      const totalObjective = targetWeight ? targetWeight - (startWeight || 0) : 0;
      const totalObjectiveAbs = Math.abs(totalObjective);

      const remaining = targetWeight ? targetWeight - (latestWeight || 0) : 0;
      const remainingAbs = Math.abs(remaining);
      let remainingDirection = 'flat';
      if (remaining > 0.05) remainingDirection = 'gain';
      else if (remaining < -0.05) remainingDirection = 'loss';

      let daysToTarget = 0;
      if (paceMeta && paceMeta.rate && paceMeta.rate > 0 && remainingAbs > 0.05) {
        daysToTarget = Math.ceil((remainingAbs / paceMeta.rate) * 7);
      }

      const paceLabel = paceMeta ? paceMeta.label : 'Normal';

      const summaryParts = [];
      if (latestWeight) {
        summaryParts.push(`Latest ${formatNumber(latestWeight, 1)} kg`);
      }
      if (hasGoal) {
        summaryParts.push(`Goal ${formatNumber(targetWeight, 1)} kg`);
        if (remainingAbs >= 0.05) {
          let descriptor = remainingDirection === 'loss' ? 'to lose' : 'to gain';
          if ((totalObjective < 0 && remainingDirection === 'gain') || (totalObjective > 0 && remainingDirection === 'loss')) {
            descriptor = 'ahead of target';
          }
          summaryParts.push(`${formatNumber(remainingAbs, 1)} kg ${descriptor}`);
        } else {
          summaryParts.push('Goal met');
        }
      }
      if (usingSyntheticHistory && !hasRealEntries) {
        summaryParts.push('Preview data — add logs to personalize');
      }

      let daysElapsed = 0;
      if (startDate && latestDate) {
        const start = new Date(startDate);
        const end = new Date(latestDate);
        if (!Number.isNaN(start.getTime()) && !Number.isNaN(end.getTime())) {
          daysElapsed = Math.max(0, Math.round((end - start) / 86400000));
        }
      }

      let direction = 'flat';
      if (totalChange > 0.05) direction = 'gain';
      else if (totalChange < -0.05) direction = 'loss';

      let objectiveDirection = 'flat';
      if (totalObjective > 0.05) objectiveDirection = 'gain';
      else if (totalObjective < -0.05) objectiveDirection = 'loss';

      if (!weeklyTrendKg && paceMeta && paceMeta.rate && latestWeight) {
        if (hasGoal && targetWeight && Math.abs(targetWeight - latestWeight) >= 0.05) {
          weeklyTrendKg = (targetWeight < latestWeight ? -1 : 1) * paceMeta.rate;
        }
      }
      const dailyTrendKg = weeklyTrendKg ? weeklyTrendKg / 7 : 0;

      let projectionWeeks = 0;
      if (weeklyTrendKg) {
        if (timelineWeeks > 0) {
          projectionWeeks = timelineWeeks;
        } else if (remainingAbs > 0.05) {
          projectionWeeks = Math.max(1, Math.ceil(remainingAbs / Math.abs(weeklyTrendKg)));
        } else if (loggedCalorieDays) {
          projectionWeeks = Math.max(1, Math.min(4, Math.ceil(loggedCalorieDays / 7)));
        }
      } else if (timelineWeeks > 0) {
        projectionWeeks = timelineWeeks;
      }

      let projectedWeight = latestWeight || 0;
      let projectedChange = 0;
      if (projectionWeeks && latestWeight) {
        projectedChange = weeklyTrendKg * projectionWeeks;
        projectedWeight = Math.max(0, latestWeight + projectedChange);
        if (hasGoal) {
          if (remaining < 0) {
            projectedWeight = Math.max(projectedWeight, targetWeight);
          } else if (remaining > 0) {
            projectedWeight = Math.min(projectedWeight, targetWeight);
          }
        }
      }

      let projectionNote = '';
      if (!latestWeight) {
        projectionNote = 'Log weight entries to unlock projections.';
      } else if (!loggedCalorieDays) {
        projectionNote = 'Log meals with calories to project your trajectory.';
      } else if (!weeklyTrendKg) {
        projectionNote = 'Current intake trends toward maintenance.';
      } else if (!projectionWeeks) {
        const directionLabel = weeklyTrendKg > 0 ? 'gain' : 'loss';
        projectionNote = `Recent intake suggests a ${directionLabel}, set a goal timeline for a projection.`;
      } else {
        const changeAbs = Math.abs(projectedChange);
        const directionLabel = projectedChange > 0 ? 'gain' : 'lose';
        const weeksLabel = `in ${projectionWeeks} week${projectionWeeks === 1 ? '' : 's'}`;
        projectionNote = `At your current ${averageDailyDelta < 0 ? 'deficit' : 'surplus'} (~${formatNumber(Math.abs(averageDailyDelta), 0)} kcal/day) you're on pace to ${directionLabel} ${formatNumber(changeAbs, 1)} kg ${weeksLabel}.`;
        if (hasGoal && Math.abs(projectedWeight - targetWeight) <= 0.05) {
          projectionNote += ' That lines up with your goal weight.';
        }
      }

      if (projectionWeeks && latestWeight && Math.abs(projectedChange) >= 0.05) {
        summaryParts.push(`Projected ${formatNumber(projectedWeight, 1)} kg (${projectionWeeks} wk)`);
      }
      const summaryNote = summaryParts.join(' · ');

      const chartData = buildWeightChartData({
        historyEntries,
        latestWeight,
        latestDate,
        targetWeight,
        hasGoal,
        dailyTrendKg,
        remaining,
        remainingAbs,
        timelineWeeks,
        projectionWeeks,
        projectionNote,
        usingSyntheticHistory,
        hasRealEntries
      });

      return {
        labels,
        data,
        startWeight,
        startDate,
        latestWeight,
        latestDate,
        totalChange,
        totalChangeAbs,
        direction,
        targetWeight,
        totalObjective,
        totalObjectiveAbs,
        objectiveDirection,
        remaining,
        remainingAbs,
        remainingDirection,
        daysToTarget,
        paceLabel,
        daysElapsed,
        hasEntries: hasRealEntries,
        hasGoal,
        paceRate: paceMeta ? paceMeta.rate : 0,
        summaryNote,
        projectedWeight,
        projectedChange,
        projectionWeeks,
        projectionNote,
        averageDailyDelta,
        maintenanceCalories,
        weeklyDeltaKg: weeklyTrendKg,
        loggedCalorieDays,
        usingSyntheticHistory,
        chartLabels: chartData.labels,
        chartDates: chartData.dates,
        historySeries: chartData.historySeries,
        projectionSeries: chartData.projectionSeries,
        goalSeries: chartData.goalSeries,
        projectionStartIndex: chartData.projectionStartIndex,
        hasHistorySeries: chartData.hasHistory,
        hasProjectionSeries: chartData.hasProjection,
        chartMessage: chartData.message
      };
    }

    function buildWeightChartData({
      historyEntries,
      latestWeight,
      latestDate,
      targetWeight,
      hasGoal,
      dailyTrendKg,
      remaining,
      remainingAbs,
      timelineWeeks,
      projectionWeeks,
      projectionNote,
      usingSyntheticHistory,
      hasRealEntries
    }) {
      const toISODate = value => {
        if (!value) return null;
        if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
          return value;
        }
        const dateObj = new Date(value);
        if (Number.isNaN(dateObj.getTime())) return null;
        return dateObj.toISOString().split('T')[0];
      };

      const roundWeight = value => (value === null || value === undefined ? null : Number(Number(value).toFixed(2)));

      const entryMap = new Map();
      historyEntries.forEach(entry => {
        const iso = toISODate(entry.date);
        if (!iso) return;
        entryMap.set(iso, Number(entry.weight || 0));
      });

      let baseIso = toISODate(latestDate);
      if (!baseIso && historyEntries.length) {
        baseIso = toISODate(historyEntries[historyEntries.length - 1].date);
      }
      if (!baseIso && entryMap.size) {
        const sorted = Array.from(entryMap.keys()).sort((a, b) => new Date(a) - new Date(b));
        baseIso = sorted[sorted.length - 1];
      }
      if (!baseIso && latestWeight) {
        baseIso = toISODate(new Date());
      }

      if (!baseIso) {
        return {
          labels: [],
          dates: [],
          historySeries: [],
          projectionSeries: [],
          goalSeries: [],
          projectionStartIndex: 0,
          hasHistory: false,
          hasProjection: false,
          message: 'Log meals with calories and weight entries to unlock projections.'
        };
      }

      const baseDate = new Date(baseIso);
      if (Number.isNaN(baseDate.getTime())) {
        return {
          labels: [],
          dates: [],
          historySeries: [],
          projectionSeries: [],
          goalSeries: [],
          projectionStartIndex: 0,
          hasHistory: false,
          hasProjection: false,
          message: 'Log meals with calories and weight entries to unlock projections.'
        };
      }

      const historyDatesSet = new Set();
      historyEntries.forEach(entry => {
        const iso = toISODate(entry.date);
        if (iso) historyDatesSet.add(iso);
      });

      for (let i = 0; i <= 6; i++) {
        const date = new Date(baseDate);
        date.setDate(date.getDate() - i);
        const iso = toISODate(date);
        if (iso) historyDatesSet.add(iso);
      }

      if (!historyDatesSet.size) {
        const iso = toISODate(baseDate);
        if (iso) historyDatesSet.add(iso);
      }

      const historyDates = Array.from(historyDatesSet).sort((a, b) => new Date(a) - new Date(b));

      let lastKnown = null;
      const historySeries = historyDates.map(date => {
        if (entryMap.has(date)) {
          lastKnown = Number(entryMap.get(date));
          return roundWeight(lastKnown);
        }
        if (lastKnown !== null) {
          return roundWeight(lastKnown);
        }
        if (latestWeight) {
          lastKnown = Number(latestWeight);
          return roundWeight(lastKnown);
        }
        return null;
      });

      const historyHasData = historySeries.some(value => value !== null);
      const historyEndDate = historyDates.length ? new Date(historyDates[historyDates.length - 1]) : baseDate;
      const baseline = historySeries.length ? historySeries[historySeries.length - 1] : (latestWeight ? roundWeight(latestWeight) : null);

      const futureDates = [];
      let projectionDays = 0;
      const defaultFutureDays = 14;

      if (baseline !== null) {
        if (dailyTrendKg) {
          const derivedDays = projectionWeeks ? Math.round(Math.max(1, projectionWeeks * 7)) : 0;
          const goalDays = hasGoal && remainingAbs > 0.05 ? Math.ceil(remainingAbs / Math.abs(dailyTrendKg)) : 0;
          projectionDays = Math.max(derivedDays, goalDays, 7);
          projectionDays = Math.min(projectionDays, 84);
        } else if (hasGoal && remainingAbs > 0.05) {
          const fallback = timelineWeeks ? Math.round(Math.max(1, timelineWeeks * 7)) : defaultFutureDays;
          projectionDays = Math.min(Math.max(fallback, 7), 84);
        } else {
          projectionDays = defaultFutureDays;
        }
      }

      for (let i = 1; i <= projectionDays; i++) {
        const date = new Date(historyEndDate);
        date.setDate(date.getDate() + i);
        const iso = toISODate(date);
        if (iso) futureDates.push(iso);
      }

      const chartDates = [...historyDates, ...futureDates];
      const projectionStartIndex = historyDates.length ? historyDates.length - 1 : 0;

      const projectionSeries = chartDates.map((date, index) => {
        if (baseline === null) return null;
        if (index < projectionStartIndex) return null;
        const daysAhead = index - projectionStartIndex;
        if (daysAhead === 0) return roundWeight(baseline);
        let value = baseline + dailyTrendKg * daysAhead;
        if (!dailyTrendKg) {
          value = baseline;
        }
        if (hasGoal && remainingAbs > 0.05) {
          if (remaining < 0) {
            value = Math.max(value, targetWeight);
          } else if (remaining > 0) {
            value = Math.min(value, targetWeight);
          }
        }
        return roundWeight(value);
      });

      const historySeriesFull = chartDates.map((date, index) => (index < historySeries.length ? historySeries[index] : null));
      const goalSeries = hasGoal ? chartDates.map(() => roundWeight(targetWeight)) : chartDates.map(() => null);

      const formatChartLabel = iso => {
        if (!iso) return '';
        const parts = iso.split('-').map(Number);
        if (parts.length === 3 && parts.every(num => !Number.isNaN(num))) {
          return new Date(parts[0], parts[1] - 1, parts[2]).toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        }
        const parsed = new Date(iso);
        if (!Number.isNaN(parsed.getTime())) {
          return parsed.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        }
        return iso;
      };

      const labels = chartDates.map(formatChartLabel);
      const hasProjection = projectionSeries.some((value, index) => index >= projectionStartIndex && value !== null);

      const message = !historyHasData
        ? 'Log meals with calories and weight entries to unlock projections.'
        : usingSyntheticHistory && !hasRealEntries
          ? 'Preview uses sample data — add weight logs to personalize.'
          : projectionNote || 'Keep logging calories and weight for sharper projections.';

      return {
        labels,
        chartLabels: labels,
        dates: chartDates,
        historySeries: historySeriesFull,
        projectionSeries,
        goalSeries,
        projectionStartIndex,
        hasHistory: historyHasData,
        hasProjection,
        message,
        chartMessage: message
      };
    }

    function generateSyntheticHistory(latestWeight, latestDate, targetWeight, paceMeta) {
      if (!latestWeight || latestWeight <= 0) return [];
      const base = latestDate ? new Date(latestDate) : new Date();
      if (Number.isNaN(base.getTime())) return [];
      const weeklyShift = paceMeta && paceMeta.rate ? paceMeta.rate : 0.6;
      const direction = targetWeight && Math.abs(targetWeight - latestWeight) >= 0.05
        ? (latestWeight > targetWeight ? 1 : -1)
        : 1;
      const dailyShift = (weeklyShift / 7) * direction;
      const history = [];
      for (let i = 7; i >= 1; i--) {
        const date = new Date(base);
        date.setDate(date.getDate() - i);
        const jitter = Math.sin(i) * 0.08 * direction;
        const weight = Math.max(0, Number((latestWeight + dailyShift * i + jitter).toFixed(1)));
        history.push({ date: date.toISOString().split('T')[0], weight });
      }
      history.push({ date: base.toISOString().split('T')[0], weight: Number(latestWeight.toFixed(1)) });
      return history;
    }

    function updateWeightSummary(weightAnalytics) {
      if (!weightChangeValue || !weightRemainingValue || !weightRemainingLabel) return;
      const {
        startDate,
        latestWeight,
        latestDate,
        totalChange,
        totalChangeAbs,
        hasGoal,
        remainingAbs,
        remainingDirection,
        targetWeight,
        daysToTarget,
        summaryNote,
        objectiveDirection,
        projectionNote,
        usingSyntheticHistory,
        hasEntries,
        chartMessage
      } = weightAnalytics;

      if (!latestWeight || latestWeight <= 0) {
        weightChangeValue.textContent = '--';
        weightChangeDirection.textContent = 'Log weights to unlock trends.';
      } else {
        weightChangeValue.textContent = totalChangeAbs < 0.05
          ? '0.0 kg'
          : formatSignedValue(totalChange, 1, 'kg');
        const since = startDate ? formatDateLabel(startDate) : '';
        const latest = latestDate ? formatDateLabel(latestDate) : '';
        if (usingSyntheticHistory && !hasEntries) {
          weightChangeDirection.textContent = 'Preview data shown — log weight entries to personalize.';
        } else if (since && latest && since !== latest) {
          weightChangeDirection.textContent = `Since ${since} · Latest update ${latest}`;
        } else if (since) {
          weightChangeDirection.textContent = `Since ${since}`;
        } else {
          weightChangeDirection.textContent = 'Tracking just started';
        }
      }

      if (!hasGoal || !targetWeight) {
        weightRemainingValue.textContent = '--';
        weightRemainingLabel.textContent = 'Set a goal weight in Settings to see this.';
      } else if (remainingAbs < 0.05) {
        weightRemainingValue.textContent = '0.0 kg';
        weightRemainingLabel.textContent = 'Goal reached — great job!';
      } else {
        weightRemainingValue.textContent = `${formatNumber(remainingAbs, 1)} kg`;
        const ahead = (objectiveDirection === 'loss' && remainingDirection === 'gain')
          || (objectiveDirection === 'gain' && remainingDirection === 'loss');
        if (ahead) {
          weightRemainingLabel.textContent = 'ahead of target';
        } else {
          weightRemainingLabel.textContent = remainingDirection === 'loss' ? 'to lose' : 'to gain';
        }
      }

      if (targetCountdownValue) {
        targetCountdownValue.textContent = hasGoal ? formatDaysToTarget(daysToTarget) : '—';
      }

      if (weightCardSummary) {
        weightCardSummary.textContent = chartMessage || projectionNote || summaryNote || 'Log meals with calories and weight entries to unlock projections.';
      }
    }

    function getWeightDatasets(weightAnalytics) {
      const historySeries = Array.isArray(weightAnalytics.historySeries) ? weightAnalytics.historySeries : [];
      const projectionSeries = Array.isArray(weightAnalytics.projectionSeries) ? weightAnalytics.projectionSeries : [];
      const goalSeries = Array.isArray(weightAnalytics.goalSeries) ? weightAnalytics.goalSeries : [];
      const projectionStartIndex = Number(weightAnalytics.projectionStartIndex || 0);

      const datasets = [];

      if (historySeries.some(value => value !== null)) {
        datasets.push({
          label: 'Current weight',
          data: historySeries.map(value => value),
          borderColor: '#15c5a3',
          backgroundColor: 'rgba(21, 197, 163, 0.18)',
          tension: 0.35,
          pointRadius: 3,
          pointHoverRadius: 5,
          fill: false,
          spanGaps: true,
          borderWidth: 2
        });
      }

      if (projectionSeries.some((value, index) => index >= projectionStartIndex && value !== null)) {
        datasets.push({
          label: 'Projected weight',
          data: projectionSeries.map(value => value),
          borderColor: '#5c7cfa',
          backgroundColor: 'rgba(92, 124, 250, 0.12)',
          borderDash: [6, 4],
          tension: 0.25,
          pointRadius: 0,
          pointHoverRadius: 4,
          fill: false,
          spanGaps: true,
          borderWidth: 2
        });
      }

      if (goalSeries.some(value => value !== null)) {
        datasets.push({
          label: 'Goal weight',
          data: goalSeries.map(value => value),
          borderColor: '#ffb347',
          borderDash: [2, 6],
          fill: false,
          tension: 0,
          pointRadius: 0,
          pointHoverRadius: 0,
          borderWidth: 2
        });
      }

      return datasets;
    }

    function renderWeightProjectionChart(weightAnalytics) {
      if (!weightProjectionCanvas) return;

      if (weightProjectionChart) {
        weightProjectionChart.destroy();
        weightProjectionChart = null;
      }

      const labels = Array.isArray(weightAnalytics.chartLabels)
        ? weightAnalytics.chartLabels
        : Array.isArray(weightAnalytics.labels)
          ? weightAnalytics.labels
          : [];
      const datasets = getWeightDatasets(weightAnalytics);
      const hasChartData = labels.length && datasets.length;

      if (!hasChartData) {
        weightProjectionCanvas.style.display = 'none';
        if (weightProjectionEmpty) {
          weightProjectionEmpty.textContent = weightAnalytics.chartMessage
            || weightAnalytics.message
            || 'Log meals with calories and weight entries to unlock projections.';
          weightProjectionEmpty.classList.remove('hidden');
        }
        return;
      }

      weightProjectionCanvas.style.display = 'block';
      if (weightProjectionEmpty) {
        weightProjectionEmpty.textContent = weightAnalytics.chartMessage || weightAnalytics.message || '';
        weightProjectionEmpty.classList.add('hidden');
      }

      const ctx = weightProjectionCanvas.getContext('2d');
      if (!ctx) return;

      const options = getChartOptions('Weight trajectory');
      options.maintainAspectRatio = false;
      options.plugins.legend.display = true;
      options.plugins.legend.labels = { color: '#d9deff' };
      options.plugins.title.text = 'Weight trajectory';
      options.scales.y.title = { display: true, text: 'kg', color: '#b5bdd6' };
      options.scales.y.beginAtZero = false;
      options.interaction = { mode: 'index', intersect: false };

      weightProjectionChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets
        },
        options
      });
    }

    function openChartZoom(type) {
      if (!chartZoomModal || !chartZoomCanvas) return;
      const ctx = chartZoomCanvas.getContext('2d');
      if (!ctx) return;
      if (chartZoomInstance) {
        chartZoomInstance.destroy();
        chartZoomInstance = null;
      }

      const titles = {
        calories: '<i class="fa-solid fa-fire"></i> Calorie trend',
        macro: '<i class="fa-solid fa-utensils"></i> Macro balance',
        water: '<i class="fa-solid fa-droplet"></i> Hydration',
        mealSplit: '<i class="fa-solid fa-clock"></i> Meals',
        weight: '<i class="fa-solid fa-scale-balanced"></i> Weight trajectory'
      };
      chartZoomTitle.innerHTML = titles[type] || '<i class="fa-solid fa-chart-line"></i> Chart insights';

      let chartVisible = false;

      if (type === 'calories') {
        const cache = analyticsCache.calories || {};
        if (cache.labels && cache.labels.length) {
          const options = getChartOptions('Calories (7 days)');
          options.maintainAspectRatio = false;
          chartZoomInstance = new Chart(ctx, {
            type: 'line',
            data: {
              labels: cache.labels,
              datasets: [{
                label: 'Calories',
                data: cache.data,
                fill: true,
                borderColor: 'rgba(21,197,163,0.9)',
                backgroundColor: 'rgba(21,197,163,0.18)',
                tension: 0.35,
                pointRadius: 4,
                pointHoverRadius: 6
              }]
            },
            options
          });
          chartVisible = true;
        }
      } else if (type === 'macro') {
        const cache = analyticsCache.macros || {};
        if (cache.total && cache.total > 0) {
          chartZoomInstance = new Chart(ctx, {
            type: 'doughnut',
            data: {
              labels: ['Protein', 'Carbs', 'Fat'],
              datasets: [{
                data: [cache.protein || 0, cache.carbs || 0, cache.fat || 0],
                backgroundColor: ['#5c7cfa', '#ffb347', '#f75f78'],
                borderWidth: 0,
                hoverOffset: 6
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  labels: { color: '#d9deff' }
                }
              }
            }
          });
          chartVisible = true;
        }
      } else if (type === 'water') {
        const cache = analyticsCache.water || {};
        if (cache.labels && cache.labels.length) {
          const options = getChartOptions('Water intake (7 days)');
          options.maintainAspectRatio = false;
          chartZoomInstance = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: cache.labels,
              datasets: [{
                label: 'Water (ml)',
                data: cache.data,
                backgroundColor: 'rgba(48, 220, 188, 0.45)',
                borderColor: 'rgba(48, 220, 188, 0.9)',
                borderWidth: 1,
                borderRadius: 8,
                borderSkipped: false
              }]
            },
            options
          });
          chartVisible = true;
        }
      } else if (type === 'mealSplit') {
        const cache = analyticsCache.mealSplit || {};
        const totals = cache.totals || {};
        const values = [totals.lunch || 0, totals.dinner || 0, (totals.breakfast || 0) + (totals.snack || 0)];
        if (values.some(value => value > 0)) {
          chartZoomInstance = new Chart(ctx, {
            type: 'doughnut',
            data: {
              labels: ['Lunch', 'Dinner', 'Breakfast/Snacks'],
              datasets: [{
                data: values,
                backgroundColor: ['#5c7cfa', '#f75f78', '#ffb347'],
                borderWidth: 0,
                hoverOffset: 6
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  labels: { color: '#d9deff' }
                }
              }
            }
          });
          chartVisible = true;
        }
      } else if (type === 'weight') {
        const cache = analyticsCache.weight || {};
        const labels = Array.isArray(cache.chartLabels) ? cache.chartLabels : [];
        const datasets = getWeightDatasets(cache);
        if (labels.length && datasets.length) {
          const options = getChartOptions('Weight trajectory');
          options.maintainAspectRatio = false;
          options.plugins.legend.display = true;
          options.plugins.legend.labels = { color: '#d9deff' };
          options.plugins.title.text = 'Weight trajectory';
          options.scales.y.title = { display: true, text: 'kg', color: '#b5bdd6' };
          options.scales.y.beginAtZero = false;
          options.interaction = { mode: 'index', intersect: false };
          chartZoomInstance = new Chart(ctx, {
            type: 'line',
            data: {
              labels,
              datasets
            },
            options
          });
          chartVisible = true;
        }
      }

      chartZoomDetails.innerHTML = buildZoomDetails(type);

      if (chartZoomCanvas.parentElement) {
        chartZoomCanvas.parentElement.style.display = chartVisible ? 'block' : 'none';
      }

      toggleModal(chartZoomModal, true);
    }

    function buildZoomDetails(type) {
      if (type === 'calories') {
        const cache = analyticsCache.calories || {};
        if (!cache.labels || !cache.labels.length) {
          return '<p>Log meals to unlock calorie insights.</p>';
        }
        const total = cache.data.reduce((sum, value) => sum + Number(value || 0), 0);
        const average = cache.data.length ? total / cache.data.length : 0;
        const max = Math.max(...cache.data);
        const min = Math.min(...cache.data);
        const maxIndex = cache.data.indexOf(max);
        const minIndex = cache.data.indexOf(min);
        const items = [
          `<li><strong>7-day total:</strong> ${formatNumber(total)} kcal</li>`,
          `<li><strong>Daily average:</strong> ${formatNumber(average, 0)} kcal</li>`
        ];
        if (maxIndex >= 0) {
          items.push(`<li><strong>Peak day:</strong> ${cache.labels[maxIndex]} (${formatNumber(max)} kcal)</li>`);
        }
        if (minIndex >= 0) {
          items.push(`<li><strong>Lightest day:</strong> ${cache.labels[minIndex]} (${formatNumber(min)} kcal)</li>`);
        }
        if (cache.target) {
          items.push(`<li><strong>Daily target:</strong> ${formatNumber(cache.target)} kcal</li>`);
        }
        return `<h4>Highlights</h4><ul>${items.join('')}</ul>`;
      }

      if (type === 'macro') {
        const cache = analyticsCache.macros || {};
        if (!cache.total || cache.total <= 0) {
          return '<p>Enable macro tracking when logging meals to see this view.</p>';
        }
        const breakdown = [
          { label: 'Protein', value: cache.protein || 0, target: cache.targets ? cache.targets.protein : 0 },
          { label: 'Carbs', value: cache.carbs || 0, target: cache.targets ? cache.targets.carbs : 0 },
          { label: 'Fat', value: cache.fat || 0, target: cache.targets ? cache.targets.fat : 0 }
        ];
        const items = breakdown.map(({ label, value, target }) => {
          const percent = cache.total ? Math.round((value / cache.total) * 100) : 0;
          const targetText = target ? ` · Target ${formatNumber(target)} g` : '';
          return `<li><strong>${label}:</strong> ${formatNumber(value, 1)} g (${percent}%)${targetText}</li>`;
        });
        const dominant = breakdown.reduce((best, item) => (item.value > best.value ? item : best), { value: -Infinity });
        if (dominant.value > 0) {
          items.push(`<li><strong>Dominant macro:</strong> ${dominant.label}</li>`);
        }
        return `<h4>Macro balance</h4><ul>${items.join('')}</ul>`;
      }

      if (type === 'water') {
        const cache = analyticsCache.water || {};
        if (!cache.labels || !cache.labels.length) {
          return '<p>Log water to unlock hydration trends.</p>';
        }
        const total = cache.data.reduce((sum, value) => sum + Number(value || 0), 0);
        const best = Math.max(...cache.data);
        const bestIndex = cache.data.indexOf(best);
        const items = [
          `<li><strong>Today:</strong> ${formatNumber(cache.today)} ml</li>`,
          `<li><strong>7-day average:</strong> ${formatNumber(Math.round(cache.average))} ml</li>`,
          `<li><strong>Weekly total:</strong> ${formatNumber(total)} ml</li>`
        ];
        if (bestIndex >= 0) {
          items.push(`<li><strong>Best day:</strong> ${cache.labels[bestIndex]} (${formatNumber(best)} ml)</li>`);
        }
        if (cache.target) {
          items.push(`<li><strong>Daily target:</strong> ${formatNumber(cache.target)} ml</li>`);
        }
        return `<h4>Hydration</h4><ul>${items.join('')}</ul>`;
      }

      if (type === 'mealSplit') {
        const cache = analyticsCache.mealSplit || {};
        const totals = cache.totals || {};
        const totalCalories = cache.totalCalories || 0;
        if (!totalCalories) {
          return '<p>Log meals with calories to see timing distribution.</p>';
        }
        const categories = [
          { key: 'breakfast', label: 'Breakfast' },
          { key: 'lunch', label: 'Lunch' },
          { key: 'snack', label: 'Snacks' },
          { key: 'dinner', label: 'Dinner' }
        ];
        const distribution = categories
          .map(({ key, label }) => {
            const value = Number(totals[key] || 0);
            const percent = totalCalories ? Math.round((value / totalCalories) * 100) : 0;
            return `<li><strong>${label}:</strong> ${formatNumber(value)} kcal (${percent}%)</li>`;
          })
          .join('');
        const averages = cache.averages || {};
        const timeItems = categories
          .map(({ key, label }) => (averages[key] ? `<li><strong>${label}:</strong> ${averages[key]}</li>` : null))
          .filter(Boolean)
          .join('');
        const timesSection = timeItems
          ? `<h4>Average meal times</h4><ul>${timeItems}</ul>`
          : '<p>Log meal times to unlock timing insights.</p>';
        return `<h4>Distribution</h4><ul>${distribution}</ul>${timesSection}`;
      }

      if (type === 'weight') {
        const weight = analyticsCache.weight || {};
        if (!weight.latestWeight || weight.latestWeight <= 0) {
          return '<p>Log weight entries to unlock progress analytics.</p>';
        }
        const items = [];
        if (weight.startWeight) {
          const startDate = formatDateLabel(weight.startDate);
          items.push(`<li><strong>Start:</strong> ${formatNumber(weight.startWeight, 1)} kg${startDate ? ` (${startDate})` : ''}</li>`);
        }
        if (weight.latestWeight) {
          const latestDate = formatDateLabel(weight.latestDate);
          items.push(`<li><strong>Latest:</strong> ${formatNumber(weight.latestWeight, 1)} kg${latestDate ? ` (${latestDate})` : ''}</li>`);
        }
        items.push(`<li><strong>Change:</strong> ${formatSignedValue(weight.totalChange, 1, 'kg')}</li>`);
        if (weight.targetWeight) {
          items.push(`<li><strong>Goal:</strong> ${formatNumber(weight.targetWeight, 1)} kg</li>`);
          if (weight.totalObjectiveAbs >= 0.05) {
            const planDescriptor = weight.totalObjective > 0 ? 'gain planned' : 'loss planned';
            items.push(`<li><strong>Total plan:</strong> ${formatSignedValue(weight.totalObjective, 1, 'kg')} (${planDescriptor})</li>`);
          }
          if (weight.remainingAbs >= 0.05) {
            const ahead = (weight.objectiveDirection === 'loss' && weight.remainingDirection === 'gain')
              || (weight.objectiveDirection === 'gain' && weight.remainingDirection === 'loss');
            const gapLabel = ahead ? 'ahead of target' : weight.remainingDirection === 'loss' ? 'to lose' : 'to gain';
            items.push(`<li><strong>Current gap:</strong> ${formatNumber(weight.remainingAbs, 1)} kg ${gapLabel}</li>`);
          } else {
            items.push('<li><strong>Current gap:</strong> Goal achieved</li>');
          }
          if (weight.daysToTarget) {
            items.push(`<li><strong>Estimated time:</strong> ${formatDaysToTarget(weight.daysToTarget)} (${weight.paceLabel} pace)</li>`);
          }
        }
        if (weight.projectionWeeks && Math.abs(weight.projectedChange || 0) >= 0.05) {
          const projectionPeriod = formatProjectionPeriod(weight.projectionWeeks);
          items.push(`<li><strong>Projected:</strong> ${formatNumber(weight.projectedWeight, 1)} kg (${projectionPeriod})</li>`);
        }
        if (weight.loggedCalorieDays) {
          const calorieTrend = weight.averageDailyDelta < 0 ? 'deficit' : 'surplus';
          items.push(`<li><strong>Calorie trend:</strong> ${calorieTrend} ~${formatNumber(Math.abs(weight.averageDailyDelta), 0)} kcal/day over ${weight.loggedCalorieDays} day${weight.loggedCalorieDays === 1 ? '' : 's'}</li>`);
        }
      if (weight.projectionNote) {
        items.push(`<li><strong>Projection note:</strong> ${weight.projectionNote}</li>`);
      }
      if (weight.daysElapsed) {
        items.push(`<li><strong>Tracking span:</strong> ${weight.daysElapsed} day${weight.daysElapsed === 1 ? '' : 's'}</li>`);
      }
      if (weight.usingSyntheticHistory && !weight.hasEntries) {
        items.push('<li><strong>Note:</strong> Preview data shown until you add real weight logs.</li>');
      }
      if (weight.chartMessage) {
        items.push(`<li><strong>Chart insight:</strong> ${weight.chartMessage}</li>`);
      }
      return `<h4>Weight insights</h4><ul>${items.join('')}</ul>`;
    }

      return '<p>Log data to unlock insights.</p>';
    }

    function getChartOptions(title) {
      return {
        plugins: {
          legend: { display: false },
          title: {
            display: true,
            text: title,
            color: '#c8cee8',
            font: { size: 14, weight: '600' }
          },
          tooltip: {
            backgroundColor: 'rgba(20,23,36,0.95)',
            borderColor: 'rgba(255,255,255,0.08)',
            borderWidth: 1,
            titleColor: '#fff',
            bodyColor: '#dfe3ff'
          }
        },
        scales: {
          x: {
            ticks: { color: '#b5bdd6' },
            grid: { color: 'rgba(255,255,255,0.05)' }
          },
          y: {
            ticks: { color: '#b5bdd6' },
            grid: { color: 'rgba(255,255,255,0.05)' }
          }
        }
      };
    }
    function renderPresetEditor() {
      const presets = getPresets();
      presetEditor.innerHTML = '';
      presets.forEach((preset, index) => {
        const row = document.createElement('div');
        row.className = 'preset-row';
        row.innerHTML = `
          <input type="text" placeholder="Name" value="${preset.name || ''}" data-field="name" data-index="${index}">
          <input type="text" placeholder="Ingredients" value="${preset.ingredients || ''}" data-field="ingredients" data-index="${index}">
          <input type="number" placeholder="Calories" value="${preset.calories || ''}" data-field="calories" data-index="${index}" min="0" step="1">
          <input type="number" placeholder="Protein" value="${preset.protein || ''}" data-field="protein" data-index="${index}" min="0" step="1">
          <input type="number" placeholder="Carbs" value="${preset.carbs || ''}" data-field="carbs" data-index="${index}" min="0" step="1">
          <input type="number" placeholder="Fat" value="${preset.fat || ''}" data-field="fat" data-index="${index}" min="0" step="1">
          <button class="secondary" data-remove="${index}"><i class="fa-solid fa-trash"></i></button>
        `;
        presetEditor.appendChild(row);
      });
      updatePresetLimitMessage(presets.length);
    }

    function updatePresetLimitMessage(count) {
      if (count >= 10) {
        presetLimit.textContent = 'Maximum of 10 presets reached. Remove one before adding more.';
        presetLimit.classList.add('visible');
      } else {
        presetLimit.textContent = '';
        presetLimit.classList.remove('visible');
      }
    }

    addPresetRow.addEventListener('click', () => {
      const presets = getPresets();
      if (presets.length >= 10) {
        updatePresetLimitMessage(presets.length);
        return;
      }
      presets.push({ name: '', ingredients: '', calories: '', protein: '', carbs: '', fat: '' });
      savePresetData(presets);
      renderPresetEditor();
    });

    presetEditor.addEventListener('input', event => {
      const field = event.target.dataset.field;
      if (!field) return;
      const index = Number(event.target.dataset.index);
      const presets = getPresets();
      presets[index][field] = event.target.value;
      savePresetData(presets);
    });

    presetEditor.addEventListener('click', event => {
      const button = event.target.closest('button[data-remove]');
      if (!button) return;
      const index = Number(button.dataset.remove);
      const presets = getPresets();
      presets.splice(index, 1);
      savePresetData(presets);
      renderPresetEditor();
      renderPresets();
    });

    savePresetsBtn.addEventListener('click', () => {
      const presets = getPresets().filter(p => p.name && p.calories);
      if (presets.length > 10) {
        updatePresetLimitMessage(presets.length);
        return;
      }
      savePresetData(presets);
      renderPresets();
      presetLimit.textContent = 'Presets saved.';
      presetLimit.classList.add('visible', 'success');
      setTimeout(() => {
        presetLimit.classList.remove('visible', 'success');
        presetLimit.textContent = '';
      }, 1800);
    });

    openPresetEditorBtn.addEventListener('click', () => {
      renderPresetEditor();
      toggleModal(presetModal, true);
    });

    document.querySelectorAll('.close-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const modalId = btn.dataset.close;
        toggleModal(document.getElementById(modalId), false);
      });
    });

    function toggleModal(modal, open) {
      if (!modal) return;
      modal.classList.toggle('open', open);
      modal.setAttribute('aria-hidden', open ? 'false' : 'true');
      if (modal === weightModal && open) {
        weightTabs.forEach(btn => btn.classList.remove('active'));
        if (weightTabs[0]) {
          weightTabs[0].classList.add('active');
        }
        selectedWeightRange = 'daily';
        updateWeightRangeUI();
        renderWeightTrendChart();
      }
      if (modal === chartZoomModal && !open) {
        if (chartZoomInstance) {
          chartZoomInstance.destroy();
          chartZoomInstance = null;
        }
        if (chartZoomDetails) {
          chartZoomDetails.innerHTML = '';
        }
        if (chartZoomCanvas && chartZoomCanvas.parentElement) {
          chartZoomCanvas.parentElement.style.display = 'block';
        }
      }
    }

    function loadProfileForm() {
      const profile = getProfile();
      ageInput.value = profile.age || '';
      weightInput.value = profile.weight || '';
      heightInput.value = profile.height || '';
      lifestyleInput.value = profile.lifestyle || 'moderate';
      updateBMI();
      updatePaceUI();
      updateGoalTypeHint();
    }

    function loadTargetsForm() {
      const targets = getTargets();
      targetCalories.value = targets.calories || '';
      targetProtein.value = targets.protein || '';
      targetCarbs.value = targets.carbs || '';
      targetFat.value = targets.fat || '';
      targetWater.value = targets.water || '';
      targetWeight.value = targets.weightTarget || '';
      goalTimeline.value = targets.goalTimeline || 12;
      selectedGoalType = targets.goalType || 'maintain';
      selectedPace = targets.goalPace || 'normal';
      updateGoalTypeButtons();
      updatePaceUI();
    }

    function updateGoalTypeButtons() {
      goalTypeGroup.querySelectorAll('button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.goal === selectedGoalType);
      });
      updateGoalTypeHint();
    }

    goalTypeGroup.addEventListener('click', event => {
      const btn = event.target.closest('button[data-goal]');
      if (!btn) return;
      selectedGoalType = btn.dataset.goal;
      updateGoalTypeButtons();
      updatePaceUI();
    });

    paceSelector.addEventListener('click', event => {
      const btn = event.target.closest('button[data-pace]');
      if (!btn) return;
      selectedPace = btn.dataset.pace;
      updatePaceUI();
    });

    paceSummary.addEventListener('click', event => {
      const card = event.target.closest('.pace-card');
      if (!card) return;
      selectedPace = card.dataset.pace;
      updatePaceUI();
    });

    [targetWeight, weightInput, ageInput, heightInput].forEach(input => {
      input.addEventListener('input', () => {
        updatePaceUI();
        if (input === targetWeight || input === weightInput) {
          updateGoalTypeHint();
        }
      });
    });
    lifestyleInput.addEventListener('change', updatePaceUI);

    function validateGoal(targetWeightValue, timelineWeeks) {
      const profile = getProfile();
      if (!profile.weight || !targetWeightValue) return { valid: true };
      const current = profile.weight;
      const diff = targetWeightValue - current;
      if (Math.abs(diff) < 0.05) return { valid: true };
      if (!timelineWeeks || timelineWeeks <= 0) {
        return { valid: false, message: 'Timeline must be positive when gaining or losing weight.' };
      }
      const weeklyChange = diff / timelineWeeks;
      const maxSafe = Math.max(1.5, current * 0.01);
      if (Math.abs(weeklyChange) > 5) {
        return { valid: false, message: 'Change exceeds ±5 kg per week. Adjust your timeline or goal.' };
      }
      if (Math.abs(weeklyChange) > maxSafe) {
        return { valid: false, message: `Weekly change of ${weeklyChange.toFixed(2)} kg exceeds the recommended ±${maxSafe.toFixed(2)} kg window.` };
      }
      if (selectedGoalType === 'maintain' && Math.abs(diff) > 0.5) {
        return { valid: false, message: 'Maintain goal selected but target weight differs by more than 0.5 kg.' };
      }
      if (selectedGoalType === 'loss' && diff >= 0) {
        return { valid: false, message: 'Loss goal requires a target weight below your current weight.' };
      }
      if (selectedGoalType === 'gain' && diff <= 0) {
        return { valid: false, message: 'Gain goal requires a target weight above your current weight.' };
      }
      return { valid: true };
    }

    saveSettingsBtn.addEventListener('click', () => {
      const profile = {
        age: Number(ageInput.value) || defaultProfile.age,
        weight: Number(weightInput.value) || defaultProfile.weight,
        height: Number(heightInput.value) || defaultProfile.height,
        lifestyle: lifestyleInput.value || 'moderate'
      };
      saveProfile(profile);
      updateBMI();

      const weightGoal = Number(targetWeight.value) || profile.weight;
      const paceData = computePaceData(profile, weightGoal);
      const chosenPace = paceData[selectedPace];
      const autoTimeline = chosenPace && chosenPace.direction !== 'maintain' ? chosenPace.weeks : 0;
      goalTimeline.value = autoTimeline;

      const targets = {
        calories: Number(targetCalories.value) || 0,
        protein: Number(targetProtein.value) || 0,
        carbs: Number(targetCarbs.value) || 0,
        fat: Number(targetFat.value) || 0,
        water: Number(targetWater.value) || 0,
        weightTarget: weightGoal,
        goalType: selectedGoalType,
        goalTimeline: autoTimeline,
        goalPace: selectedPace
      };

      const validation = validateGoal(targets.weightTarget, targets.goalTimeline);
      if (!validation.valid) {
        targetAlert.textContent = validation.message;
        targetAlert.classList.add('visible');
        targetSuccess.classList.remove('visible');
        return;
      }

      targetAlert.classList.remove('visible');
      saveTargets(targets);
      targetSuccess.textContent = 'Settings saved and synced.';
      targetSuccess.classList.add('visible');
      setTimeout(() => targetSuccess.classList.remove('visible'), 2000);
      renderSummary();
      updatePaceUI();
      renderWeightTrendChart();
    });

    function refreshWeightWidget() {
      const weights = getWeights();
      const targets = getTargets();
      const latest = weights.length ? weights[weights.length - 1].weight : getProfile().weight;
      if (latest) {
        weightValue.textContent = `${formatNumber(latest, 1)} kg`;
      } else {
        weightValue.textContent = '--';
      }
      let trendIcon = 'fa-minus';
      let trendClass = 'trend-flat';
      let trendText = 'No change';
      if (weights.length > 1) {
        const prev = weights[weights.length - 2].weight;
        const diff = latest - prev;
        if (Math.abs(diff) < 0.05) {
          trendIcon = 'fa-arrows-left-right';
          trendClass = 'trend-flat';
          trendText = 'Stable';
        } else if (diff > 0) {
          trendIcon = 'fa-arrow-up';
          trendClass = 'trend-up';
          trendText = `+${diff.toFixed(1)} kg`;
        } else {
          trendIcon = 'fa-arrow-down';
          trendClass = 'trend-down';
          trendText = `${diff.toFixed(1)} kg`;
        }
      } else if (latest) {
        trendText = 'Log more entries';
        trendClass = 'trend-flat';
      } else {
        trendText = 'No data';
      }
      weightTrend.className = `weight-trend ${trendClass}`;
      weightTrend.innerHTML = `<i class="fa-solid ${trendIcon}"></i> ${trendText}`;
    }
    weightWidget.addEventListener('click', () => {
      const today = new Date().toISOString().split('T')[0];
      weightDate.value = today;
      weightEntry.value = getProfile().weight || '';
      toggleModal(weightModal, true);
    });

    weightForm.addEventListener('submit', event => {
      event.preventDefault();
      if (!weightDate.value || !weightEntry.value) return;
      const entries = getWeights();
      const existing = entries.findIndex(e => e.date === weightDate.value);
      const payload = { date: weightDate.value, weight: Number(weightEntry.value) };
      if (existing >= 0) {
        entries[existing] = payload;
      } else {
        entries.push(payload);
      }
      entries.sort((a, b) => new Date(a.date) - new Date(b.date));
      saveWeights(entries);
      weightForm.reset();
      weightDate.value = new Date().toISOString().split('T')[0];
      renderWeightTrendChart();
      refreshWeightWidget();
      updateAnalytics(getMeals(dateInput.value));
    });

    weightTabs.forEach(btn => {
      btn.addEventListener('click', () => {
        if (btn.disabled) return;
        weightTabs.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedWeightRange = btn.dataset.range;
        renderWeightTrendChart();
      });
    });

    function updateWeightRangeUI() {
      if (!weightRangeLength || !weightCustomRange) return;
      const useCustom = weightRangeLength.value === 'custom';
      weightCustomRange.classList.toggle('visible', useCustom);
      if (useCustom) {
        const todayIso = new Date().toISOString().split('T')[0];
        const weights = getWeights();
        const latestEntryIso = weights.length ? weights[weights.length - 1].date : todayIso;
        if (weightRangeEnd && !weightRangeEnd.value) {
          weightRangeEnd.value = latestEntryIso || todayIso;
        }
        if (weightRangeStart && !weightRangeStart.value) {
          const endDate = weightRangeEnd && weightRangeEnd.value
            ? new Date(weightRangeEnd.value)
            : new Date(latestEntryIso || todayIso);
          if (!Number.isNaN(endDate.getTime())) {
            endDate.setDate(endDate.getDate() - 29);
            weightRangeStart.value = endDate.toISOString().split('T')[0];
          }
        }
      }
    }

    if (weightRangeLength) {
      weightRangeLength.addEventListener('change', () => {
        updateWeightRangeUI();
        renderWeightTrendChart();
      });
      updateWeightRangeUI();
    }

    [weightRangeStart, weightRangeEnd].forEach(input => {
      if (!input) return;
      input.addEventListener('change', () => {
        renderWeightTrendChart();
      });
    });

    function normaliseDate(value) {
      if (!value) return null;
      const date = value instanceof Date ? new Date(value.getTime()) : new Date(value);
      if (Number.isNaN(date.getTime())) return null;
      date.setHours(0, 0, 0, 0);
      return date;
    }

    function isoFromDate(date) {
      if (!date) return '';
      return date.toISOString().split('T')[0];
    }

    function startOfWeek(date) {
      const base = normaliseDate(date);
      if (!base) return null;
      const day = base.getDay();
      const diff = (day + 6) % 7;
      base.setDate(base.getDate() - diff);
      return base;
    }

    function allowedAggregations(spanDays) {
      if (!spanDays || spanDays <= 0) return ['daily'];
      if (spanDays <= 45) return ['daily', 'weekly'];
      if (spanDays <= 210) return ['daily', 'weekly', 'monthly'];
      return ['weekly', 'monthly'];
    }

    function updateWeightAggregationAvailability(spanDays) {
      const allowed = allowedAggregations(spanDays);
      if (!allowed.includes(selectedWeightRange)) {
        selectedWeightRange = allowed[0];
      }
      weightTabs.forEach(btn => {
        const mode = btn.dataset.range;
        const enabled = allowed.includes(mode);
        btn.disabled = !enabled;
        btn.classList.toggle('active', mode === selectedWeightRange);
      });
    }

    function getWeightRangeBounds(entries) {
      const latestEntry = entries.length ? entries[entries.length - 1] : null;
      let latestDate = normaliseDate(latestEntry ? latestEntry.date : new Date());
      if (!latestDate) latestDate = normaliseDate(new Date());
      if (!weightRangeLength) {
        return { start: latestDate, end: latestDate, spanDays: 1 };
      }
      const mode = weightRangeLength.value || '90';
      let startDate;
      let endDate;

      if (mode === 'custom') {
        const customStart = normaliseDate(weightRangeStart && weightRangeStart.value);
        const customEnd = normaliseDate(weightRangeEnd && weightRangeEnd.value);
        if (customStart && customEnd) {
          startDate = customStart <= customEnd ? customStart : customEnd;
          endDate = customEnd >= customStart ? customEnd : customStart;
        } else if (customStart) {
          startDate = customStart;
          endDate = latestDate >= customStart ? latestDate : customStart;
        } else if (customEnd) {
          endDate = customEnd;
          startDate = normaliseDate(new Date(customEnd.getTime() - (29 * MS_PER_DAY)));
        } else {
          endDate = latestDate;
          startDate = normaliseDate(new Date(latestDate.getTime() - (89 * MS_PER_DAY)));
        }
      } else {
        const days = Number(mode) || 90;
        endDate = latestDate;
        startDate = normaliseDate(new Date(latestDate.getTime() - ((Math.max(1, days) - 1) * MS_PER_DAY)));
      }

      if (!startDate || !endDate) {
        return { start: latestDate, end: latestDate, spanDays: 1 };
      }

      const spanDays = Math.max(1, Math.round((endDate - startDate) / MS_PER_DAY) + 1);
      return { start: startDate, end: endDate, spanDays };
    }

    function aggregateWeightEntries(entries, startDate, endDate, mode) {
      if (!entries.length || !startDate || !endDate) return [];
      const buckets = new Map();
      entries.forEach(entry => {
        const date = normaliseDate(entry.date);
        if (!date || date < startDate || date > endDate) return;
        let bucketDate;
        if (mode === 'weekly') {
          bucketDate = startOfWeek(date);
        } else if (mode === 'monthly') {
          bucketDate = normaliseDate(new Date(date.getFullYear(), date.getMonth(), 1));
        } else {
          bucketDate = date;
        }
        const iso = isoFromDate(bucketDate);
        if (!buckets.has(iso)) buckets.set(iso, []);
        buckets.get(iso).push(Number(entry.weight || 0));
      });
      const keys = Array.from(buckets.keys()).sort((a, b) => new Date(a) - new Date(b));
      return keys.map(key => {
        const values = buckets.get(key) || [];
        const avg = values.length ? values.reduce((sum, value) => sum + value, 0) / values.length : 0;
        const bucketDate = normaliseDate(key);
        const label = mode === 'monthly'
          ? bucketDate.toLocaleDateString(undefined, { month: 'short', year: 'numeric' })
          : bucketDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        return { iso: key, date: bucketDate, label, weight: Number(avg.toFixed(2)) };
      });
    }

    function computeEnergyBalanceInsights(startDate, endDate) {
      const profile = getProfile();
      const tdee = calculateTDEE(profile);
      if (!startDate || !endDate || !tdee) {
        return { tdee: tdee || 0, dailyIntake: 0, netDeficit: 0, slopePerDay: 0, loggedDays: 0 };
      }
      const spanDays = Math.max(1, Math.round((endDate - startDate) / MS_PER_DAY) + 1);
      let totalCalories = 0;
      let loggedDays = 0;
      const cursor = new Date(startDate);
      while (cursor <= endDate) {
        const iso = isoFromDate(cursor);
        const meals = getMeals(iso);
        if (meals && meals.length) {
          const dayCalories = meals.reduce((sum, meal) => sum + Number(meal.calories || 0), 0);
          totalCalories += dayCalories;
          if (dayCalories > 0) loggedDays += 1;
        }
        cursor.setDate(cursor.getDate() + 1);
      }
      const dailyIntake = loggedDays ? totalCalories / spanDays : 0;
      const netDeficit = loggedDays ? tdee - dailyIntake : 0;
      const slopePerDay = loggedDays ? -netDeficit / KCAL_PER_KG : 0;
      return { tdee, dailyIntake, netDeficit, slopePerDay, loggedDays };
    }

    function buildProjectionSeries(buckets, slopePerDay) {
      if (!buckets.length || !Number.isFinite(slopePerDay)) return [];
      const baseline = buckets[0];
      if (!baseline || !Number.isFinite(baseline.weight)) return [];
      return buckets.map(bucket => {
        const diffDays = Math.round((bucket.date - baseline.date) / MS_PER_DAY);
        const projected = baseline.weight + slopePerDay * diffDays;
        return Number(projected.toFixed(2));
      });
    }

    function renderWeightTrendChart() {
      if (!weightTrendCanvas) return;
      if (weightTrendChart) {
        weightTrendChart.destroy();
        weightTrendChart = null;
      }

      const rawEntries = getWeights().filter(entry => Number(entry.weight) > 0);
      if (!rawEntries.length) {
        const ctx = weightTrendCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, weightTrendCanvas.width || weightTrendCanvas.clientWidth || 0, weightTrendCanvas.height || weightTrendCanvas.clientHeight || 0);
        }
        if (etaText) {
          etaText.textContent = 'Log weight entries to unlock the trend view.';
        }
        return;
      }

      const range = getWeightRangeBounds(rawEntries);
      updateWeightAggregationAvailability(range.spanDays);

      const filteredRaw = rawEntries.filter(entry => {
        const date = normaliseDate(entry.date);
        return date && date >= range.start && date <= range.end;
      });

      if (!filteredRaw.length) {
        const ctx = weightTrendCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, weightTrendCanvas.width || weightTrendCanvas.clientWidth || 0, weightTrendCanvas.height || weightTrendCanvas.clientHeight || 0);
        }
        if (etaText) {
          etaText.textContent = 'No weight entries in the selected range yet.';
        }
        return;
      }

      const filtered = filteredRaw.map(entry => ({
        date: normaliseDate(entry.date),
        weight: Number(entry.weight)
      }));

      const buckets = aggregateWeightEntries(filtered, range.start, range.end, selectedWeightRange);
      if (!buckets.length) {
        if (selectedWeightRange !== 'daily') {
          selectedWeightRange = 'daily';
          updateWeightAggregationAvailability(range.spanDays);
          renderWeightTrendChart();
        }
        return;
      }

      const labels = buckets.map(bucket => bucket.label);
      const actualWeights = buckets.map(bucket => bucket.weight);
      const targets = getTargets();
      const energy = computeEnergyBalanceInsights(range.start, range.end);
      const projection = buildProjectionSeries(buckets, energy.slopePerDay);
      const projectionAvailable = energy.loggedDays > 0 && projection.some((value, index) => {
        if (!Number.isFinite(value) || Number.isNaN(value)) return false;
        return index === 0 ? false : Math.abs(value - projection[0]) > 0.01;
      });
      const goalWeight = Number(targets.weightTarget) || 0;
      const datasets = [
        {
          label: 'Actual weight',
          data: actualWeights,
          fill: false,
          borderColor: '#5c7cfa',
          backgroundColor: '#5c7cfa',
          tension: 0.35,
          pointRadius: actualWeights.length === 1 ? 4 : 3,
          pointHoverRadius: 5
        }
      ];
      if (projectionAvailable) {
        datasets.push({
          label: 'Projected weight',
          data: projection,
          borderColor: '#15c5a3',
          backgroundColor: 'rgba(21, 197, 163, 0.12)',
          borderDash: [6, 6],
          tension: 0.2,
          pointRadius: 0,
          pointHoverRadius: 4,
          fill: false
        });
      }
      if (goalWeight) {
        const goalSeries = buckets.map(() => Number(goalWeight.toFixed(2)));
        datasets.push({
          label: 'Goal weight',
          data: goalSeries,
          borderColor: '#ffb347',
          borderDash: [2, 6],
          tension: 0,
          pointRadius: 0,
          pointHoverRadius: 0,
          fill: false
        });
      }

      const minWidth = Math.max(640, buckets.length * 90);
      weightTrendCanvas.style.minWidth = `${minWidth}px`;

      const ctx = weightTrendCanvas.getContext('2d');
      weightTrendChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets
        },
        options: {
          plugins: {
            legend: {
              labels: { color: '#dfe3ff' }
            },
            tooltip: {
              backgroundColor: 'rgba(20,23,36,0.95)',
              borderColor: 'rgba(255,255,255,0.08)',
              borderWidth: 1,
              titleColor: '#fff',
              bodyColor: '#dfe3ff'
            }
          },
          scales: {
            x: {
              ticks: { color: '#b5bdd6' },
              grid: { color: 'rgba(255,255,255,0.05)' }
            },
            y: {
              ticks: { color: '#b5bdd6' },
              grid: { color: 'rgba(255,255,255,0.05)' }
            }
          }
        }
      });

      if (etaText) {
        const weeklyChange = energy.netDeficit ? (energy.netDeficit * 7) / KCAL_PER_KG : 0;
        let energyMessage;
        if (energy.tdee && energy.loggedDays) {
          if (Math.abs(weeklyChange) < 0.05) {
            energyMessage = `Energy balance is near maintenance (~${formatNumber(energy.dailyIntake, 0)} kcal intake vs ${formatNumber(energy.tdee, 0)} kcal TDEE).`;
          } else {
            const directionWord = weeklyChange >= 0 ? 'loss' : 'gain';
            energyMessage = `Energy balance (~${formatNumber(energy.dailyIntake, 0)} kcal intake vs ${formatNumber(energy.tdee, 0)} kcal TDEE) points to about ${formatNumber(Math.abs(weeklyChange), 2)} kg ${directionWord} per week.`;
          }
        } else if (energy.tdee) {
          energyMessage = 'Log meals with calories to estimate your energy balance.';
        } else {
          energyMessage = 'Add profile details to estimate energy balance.';
        }
        const etaMessage = buildETA(filteredRaw, targets);
        etaText.textContent = `${energyMessage} ${etaMessage}`.trim();
      }
    }

    function buildETA(entries, targets) {
      if (entries.length < 2) {
        return 'Not enough data for an ETA yet. Log a few more entries.';
      }
      const recent = entries.slice(-6);
      const dates = recent.map(e => new Date(e.date).getTime());
      const weights = recent.map(e => e.weight);
      const trend = linearRegression(dates, weights);
      const slopePerMs = trend.slope;
      if (Math.abs(slopePerMs) < 1e-6) {
        return 'Weight trend is flat. Adjust nutrition to move toward the goal.';
      }
      const latest = recent[recent.length - 1];
      const target = targets.weightTarget || latest.weight;
      const msPerDay = 86400000;
      const slopePerDay = slopePerMs * msPerDay;
      const days = (target - latest.weight) / slopePerDay;
      if (days < 0) {
        return 'Current trend is moving away from goal. Reassess strategy.';
      }
      const etaDate = new Date(new Date(latest.date).getTime() + days * msPerDay);
      const diffDays = Math.round(days);
      const weeks = Math.max(1, Math.round(diffDays / 7));
      return `Projected ETA: ${etaDate.toLocaleDateString()} (~${weeks} week${weeks !== 1 ? 's' : ''}) based on recent trend.`;
    }

    function linearRegression(x, y) {
      const n = x.length;
      const sumX = x.reduce((a,b) => a + b, 0);
      const sumY = y.reduce((a,b) => a + b, 0);
      const sumXY = x.reduce((acc, val, idx) => acc + val * y[idx], 0);
      const sumXX = x.reduce((acc, val) => acc + val * val, 0);
      const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX || 1);
      const intercept = (sumY - slope * sumX) / n;
      return { slope, intercept };
    }

    function loadInitialDate() {
      const today = new Date().toISOString().split('T')[0];
      dateInput.value = today;
    }

    dateInput.addEventListener('change', () => {
      renderMeals();
      renderSummary();
      setDefaultMealTime();
    });

    document.addEventListener('keydown', event => {
      if (event.key === 'Escape') {
        toggleModal(presetModal, false);
        toggleModal(weightModal, false);
        toggleModal(calorieModal, false);
        toggleModal(historyModal, false);
      }
    });

    document.addEventListener('click', event => {
      if (event.target.classList.contains('modal')) {
        toggleModal(event.target, false);
      }
    });

    function init() {
      loadInitialDate();
      loadProfileForm();
      loadTargetsForm();
      renderPresets();
      renderMeals();
      renderSummary();
      const today = new Date().toISOString().split('T')[0];
      weightDate.value = today;
      weightTabs[0].classList.add('active');
    }

    init();
  });
  </script>
</body>
</html>
