<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Own Your Prime â€“ Kanban Board</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%' stop-color='%2346f3b0'/%3E%3Cstop offset='100%' stop-color='%237b8bff'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='%23101a34'/%3E%3Cpath d='M16 44L28 20l8 12 12-16' fill='none' stroke='url(%23g)' stroke-width='6' stroke-linecap='round' stroke-linejoin='round'/%3E%3Ccircle cx='28' cy='20' r='4' fill='%23ff9a62'/%3E%3Ccircle cx='48' cy='16' r='3' fill='%23ff4477'/%3E%3C/svg%3E'>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-bg: #030712;
      --color-surface: #101a34;
      --color-surface-alt: #152245;
      --color-card: #1b2c57;
      --color-card-hover: #203467;
      --color-text: #f5f7ff;
      --color-muted: #9fb0d9;
      --color-primary: #46f3b0;
      --color-primary-dark: #13c78d;
      --color-accent: #7b8bff;
      --color-danger: #ff6b81;
      --color-warning: #f7c948;
      --color-info: #8e59ff;
      --priority-urgent: #ff4477;
      --priority-high: #ff9a62;
      --priority-medium: #ffdb5b;
      --priority-low: #4ad4a3;
      --shadow-elevated: 0 20px 60px rgba(5, 11, 31, 0.55);
      --radius-large: 18px;
      --radius-medium: 12px;
      --radius-small: 8px;
      --transition-fast: 0.2s ease;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at top right, rgba(70, 243, 176, 0.12), transparent 55%),
                  radial-gradient(circle at bottom left, rgba(139, 148, 255, 0.12), transparent 55%),
                  var(--color-bg);
      color: var(--color-text);
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    header {
      padding: 22px clamp(20px, 5vw, 48px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(135deg, rgba(21, 34, 69, 0.95), rgba(8, 15, 33, 0.92));
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 12px 40px rgba(3, 7, 18, 0.35);
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(12px);
    }

    header .brand {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 3vw, 2.2rem);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    header .tagline {
      margin: 0;
      font-size: 0.9rem;
      color: var(--color-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    #currentDateTime {
      font-size: 0.9rem;
      color: var(--color-muted);
    }

    #driveStatus {
      padding: 10px 16px;
      background: rgba(18, 30, 61, 0.65);
      border-radius: var(--radius-medium);
      font-size: 0.85rem;
      color: var(--color-muted);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 170px;
      justify-content: center;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.08);
      transition: background var(--transition-fast), color var(--transition-fast), border var(--transition-fast);
      position: relative;
    }

    #driveStatus::after {
      content: '\25BE';
      font-size: 0.7rem;
      opacity: 0.75;
    }

    #driveStatus:hover,
    #driveStatus:focus-visible {
      background: rgba(27, 44, 87, 0.8);
      border-color: rgba(70, 243, 176, 0.45);
      color: var(--color-text);
      outline: none;
    }

    .drive-control {
      position: relative;
    }

    .drive-menu {
      position: absolute;
      right: 0;
      top: calc(100% + 6px);
      background: rgba(15, 24, 46, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-medium);
      box-shadow: 0 18px 40px rgba(3, 7, 18, 0.45);
      padding: 10px;
      display: none;
      flex-direction: column;
      gap: 6px;
      min-width: 180px;
      z-index: 15;
    }

    .drive-menu.open {
      display: flex;
    }

    .drive-menu button {
      background: transparent;
      border: none;
      padding: 8px 10px;
      border-radius: var(--radius-small);
      font-size: 0.85rem;
      color: var(--color-text);
      justify-content: flex-start;
    }

    .drive-menu button:hover {
      background: rgba(70, 243, 176, 0.1);
    }

    main {
      flex: 1;
      padding: clamp(20px, 5vw, 48px);
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    #kanbanSection {
      background: rgba(12, 20, 42, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-large);
      padding: clamp(20px, 4vw, 36px);
      box-shadow: var(--shadow-elevated);
      backdrop-filter: blur(16px);
      display: flex;
      flex-direction: column;
      gap: 18px;
      max-width: 1400px;
      width: 100%;
      margin: 0 auto;
    }

    .board-header {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      align-items: flex-start;
      justify-content: space-between;
    }

    .board-title h2 {
      margin: 0;
      font-size: clamp(1.3rem, 2.5vw, 1.8rem);
    }

    .board-title p {
      margin: 4px 0 0;
      color: var(--color-muted);
      font-size: 0.95rem;
    }

    .board-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: flex-end;
      align-items: center;
      position: relative;
    }

    .board-actions input[type="text"] {
      min-width: 200px;
      padding: 10px 14px;
      border-radius: var(--radius-medium);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(27, 44, 87, 0.55);
      color: var(--color-text);
      font-size: 0.95rem;
      transition: border var(--transition-fast), box-shadow var(--transition-fast);
    }

    .board-actions input[type="text"]:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(70, 243, 176, 0.25);
    }

    button {
      border: none;
      border-radius: var(--radius-medium);
      padding: 10px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--color-text);
      background: linear-gradient(135deg, rgba(70, 243, 176, 0.85), rgba(123, 139, 255, 0.85));
      cursor: pointer;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(70, 243, 176, 0.25);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .ghost-button {
      background: rgba(36, 52, 96, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: none;
    }

    .filter-count {
      background-color: rgba(255, 69, 110, 0.95);
      color: #fff;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.7rem;
    }

    .filter-control,
    .data-menu {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    #filterBtn,
    #dataMenuBtn {
      background: rgba(36, 52, 96, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 10px;
      border-radius: var(--radius-medium);
      font-size: 0.85rem;
      box-shadow: none;
      gap: 6px;
    }

    #filterBtn:hover,
    #dataMenuBtn:hover,
    #filterBtn:focus-visible,
    #dataMenuBtn:focus-visible {
      outline: none;
      border-color: rgba(70, 243, 176, 0.4);
      background: rgba(27, 44, 87, 0.85);
    }

    #dataMenuBtn {
      font-size: 0.9rem;
    }

    .filter-menu,
    .data-dropdown {
      position: absolute;
      right: 0;
      top: calc(100% + 6px);
      background: rgba(15, 24, 46, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-medium);
      padding: 10px;
      box-shadow: 0 18px 40px rgba(3, 7, 18, 0.45);
      display: none;
      flex-direction: column;
      gap: 8px;
      min-width: 190px;
      z-index: 15;
    }

    .filter-menu.open,
    .data-dropdown.open {
      display: flex;
    }

    .filter-menu label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .filter-menu-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 6px;
    }

    .filter-menu input[type="checkbox"] {
      accent-color: var(--color-primary);
    }

    .data-dropdown button {
      background: transparent;
      border: none;
      padding: 8px 10px;
      border-radius: var(--radius-small);
      font-size: 0.85rem;
      color: var(--color-text);
      justify-content: flex-start;
    }

    .data-dropdown button:hover {
      background: rgba(70, 243, 176, 0.1);
    }

    .danger-button {
      background: linear-gradient(135deg, rgba(255, 107, 129, 0.9), rgba(255, 120, 94, 0.85));
      box-shadow: 0 8px 20px rgba(255, 107, 129, 0.25);
    }

    #filterBtn.filter-active {
      background: linear-gradient(135deg, rgba(255, 69, 110, 0.9), rgba(255, 107, 129, 0.9));
      box-shadow: 0 0 15px rgba(255, 69, 110, 0.5);
    }

    #overdueNotice {
      display: none;
      border-radius: var(--radius-medium);
      background: rgba(255, 107, 129, 0.18);
      color: var(--color-text);
      border: 1px solid rgba(255, 107, 129, 0.35);
      font-size: 0.9rem;
      overflow: hidden;
    }

    #overdueNotice.collapsed .focus-body {
      display: none;
    }

    .focus-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 14px;
      gap: 12px;
      background: rgba(255, 107, 129, 0.22);
    }

    .focus-header h3 {
      margin: 0;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .focus-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .focus-actions select,
    .focus-actions button {
      background: rgba(27, 44, 87, 0.4);
      color: var(--color-text);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: var(--radius-small);
      font-size: 0.8rem;
      padding: 6px 10px;
    }

    .focus-actions button {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .focus-body {
      padding: 12px 14px 14px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .focus-body p {
      margin: 0;
    }

    .kanban-board {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
    }

    .kanban-column {
      background: linear-gradient(165deg, rgba(27, 44, 87, 0.9), rgba(13, 22, 45, 0.85));
      border-radius: var(--radius-large);
      padding: 16px 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      position: relative;
      overflow: hidden;
    }

    .kanban-column h3 {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      gap: 12px;
    }

    .kanban-column h3 span.task-count {
      font-size: 0.85rem;
      color: var(--color-muted);
      margin-left: auto;
      letter-spacing: 0;
      background: rgba(27, 44, 87, 0.65);
      padding: 4px 8px;
      border-radius: 999px;
    }

    .kanban-tasks {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 4px;
    }

    .kanban-tasks::-webkit-scrollbar {
      width: 6px;
    }

    .kanban-tasks::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.12);
      border-radius: 999px;
    }

    .kanban-card {
      background: linear-gradient(165deg, rgba(27, 44, 87, 0.95), rgba(17, 28, 55, 0.92));
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-left: 4px solid var(--priority-low);
      border-radius: var(--radius-medium);
      padding: 14px 16px;
      box-shadow: 0 14px 32px rgba(5, 10, 24, 0.35);
      display: flex;
      flex-direction: column;
      gap: 10px;
      cursor: grab;
      transition: transform var(--transition-fast), border var(--transition-fast), box-shadow var(--transition-fast);
    }

    .kanban-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 40px rgba(5, 10, 24, 0.45);
    }

    .kanban-card[data-priority="urgent"] { border-left-color: var(--priority-urgent); }
    .kanban-card[data-priority="high"] { border-left-color: var(--priority-high); }
    .kanban-card[data-priority="medium"] { border-left-color: var(--priority-medium); }
    .kanban-card[data-priority="low"] { border-left-color: var(--priority-low); }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
    }

    .card-header h4 {
      margin: 0;
      font-size: 1rem;
      line-height: 1.4;
    }

    .action-buttons {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .action-buttons button {
      padding: 6px 8px;
      border-radius: var(--radius-small);
      font-size: 0.85rem;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid transparent;
      box-shadow: none;
    }

    .action-buttons button:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: none;
      box-shadow: none;
    }

    .kanban-card p {
      margin: 0;
      color: var(--color-muted);
      font-size: 0.9rem;
    }

    .subtask-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.85rem;
    }

    .subtask-text.done {
      text-decoration: line-through;
      color: var(--color-muted);
    }

    .card-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.75rem;
      color: var(--color-muted);
    }

    .overdue-time {
      color: var(--color-danger);
      font-weight: 600;
    }

    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .assigned {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .avatar {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .priority-label {
      padding: 4px 8px;
      border-radius: var(--radius-small);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .notes-field {
      width: 100%;
      min-height: 70px;
      padding: 10px 12px;
      border-radius: var(--radius-medium);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(21, 34, 69, 0.7);
      color: var(--color-text);
      resize: vertical;
      font-size: 0.85rem;
    }

    .task-notes {
      font-style: italic;
      color: var(--color-muted);
      font-size: 0.85rem;
    }

    .history-controls {
      display: flex;
      justify-content: flex-end;
      margin-top: 6px;
    }

    #clearHistoryBtn {
      font-size: 0.8rem;
      padding: 8px 12px;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(3, 6, 18, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(6px);
    }

    .modal-content {
      background: linear-gradient(160deg, rgba(21, 34, 69, 0.95), rgba(9, 15, 33, 0.96));
      color: var(--color-text);
      border-radius: var(--radius-large);
      padding: 24px;
      width: min(520px, 90vw);
      box-shadow: var(--shadow-elevated);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .modal-content h3 {
      margin: 0 0 6px;
      font-size: 1.3rem;
    }

    .modal-content form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .modal-content label {
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .modal-content input,
    .modal-content textarea,
    .modal-content select {
      padding: 10px 12px;
      border-radius: var(--radius-medium);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(27, 44, 87, 0.7);
      color: var(--color-text);
      font-size: 0.9rem;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
    }

    .priority-boxes {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .priority-box {
      padding: 8px 12px;
      border-radius: var(--radius-small);
      color: #fff;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      opacity: 0.65;
      transition: transform var(--transition-fast), opacity var(--transition-fast), box-shadow var(--transition-fast);
    }

    .priority-box.selected {
      opacity: 1;
      transform: translateY(-1px) scale(1.05);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    }

    .priority-box.urgent { background: var(--priority-urgent); }
    .priority-box.high { background: var(--priority-high); }
    .priority-box.medium { background: var(--priority-medium); color: #2b1a06; }
    .priority-box.low { background: var(--priority-low); color: #062a1d; }

    #cardZoomModal .zoom-actions {
      display: flex;
      justify-content: flex-end;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 18px;
    }

    #cardZoomModal .zoom-actions button {
      padding: 8px 14px;
      font-size: 0.85rem;
    }

    @media (max-width: 900px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 18px;
      }

      .drive-control {
        width: 100%;
      }

      #driveStatus {
        align-self: stretch;
        justify-content: center;
        width: 100%;
      }

      .board-actions {
        justify-content: flex-start;
      }

      .kanban-tasks {
        max-height: 50vh;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <h1>Own Your Prime</h1>
      <p class="tagline">Execute relentlessly. Celebrate intentionally.</p>
    </div>
    <div id="currentDateTime"></div>
    <div class="drive-control">
      <button id="driveStatus" type="button" aria-haspopup="true" aria-expanded="false">Google Drive: Offline</button>
      <div class="drive-menu" id="driveMenu" role="menu" aria-labelledby="driveStatus">
        <button type="button" id="driveConnectBtn" role="menuitem">Connect</button>
        <button type="button" id="driveDisconnectBtn" role="menuitem" disabled>Disconnect</button>
        <button type="button" id="driveSaveNowBtn" role="menuitem" disabled>Save snapshot now</button>
        <button type="button" id="driveLoadBtn" role="menuitem" disabled>Load latest backup</button>
      </div>
    </div>
  </header>
  <main>
    <section id="kanbanSection">
      <div class="board-header">
        <div class="board-title">
          <h2>Command Center</h2>
          <p>Focus on what matters now, next, and never again.</p>
        </div>
        <div class="board-actions">
          <input type="text" id="taskSearch" placeholder="Search tasks, notes, or assignees..." />
          <button id="addTaskBtn">+ Task</button>
          <div class="filter-control">
            <button id="filterBtn" type="button">Filter<span id="filterCount" class="filter-count" style="display:none;">0</span></button>
            <div id="filterMenu" class="filter-menu" role="menu" aria-labelledby="filterBtn">
              <label><input type="checkbox" value="urgent" />Urgent tasks</label>
              <label><input type="checkbox" value="overdue" />Overdue tasks</label>
              <label><input type="checkbox" value="dueSoon" />Due within 7 days</label>
              <div class="filter-menu-actions">
                <button type="button" id="clearFiltersBtn" class="ghost-button">Clear filters</button>
              </div>
            </div>
          </div>
          <div class="data-menu">
            <button id="dataMenuBtn" type="button" aria-haspopup="true" aria-expanded="false" aria-controls="dataDropdown" title="Import or export data">â˜°</button>
            <div id="dataDropdown" class="data-dropdown" role="menu" aria-labelledby="dataMenuBtn">
              <button type="button" id="exportBtn" role="menuitem">Export JSON</button>
              <button type="button" id="importBtn" role="menuitem">Import JSON</button>
            </div>
          </div>
          <input type="file" id="importFile" accept="application/json" hidden />
        </div>
      </div>
      <div id="overdueNotice" class="collapsed" aria-live="polite">
        <div class="focus-header">
          <h3><span aria-hidden="true">âš </span> Focus</h3>
          <div class="focus-actions">
            <select id="focusSnoozeSelect" aria-label="Snooze focus warning">
              <option value="">Snoozeâ€¦</option>
              <option value="5">5 minutes</option>
              <option value="15">15 minutes</option>
              <option value="30">30 minutes</option>
              <option value="60">1 hour</option>
              <option value="1440">24 hours</option>
              <option value="clear">Clear snooze</option>
              <option value="custom">Customâ€¦</option>
            </select>
            <button type="button" id="focusToggleBtn" aria-expanded="false" aria-controls="focusBody">Expand</button>
          </div>
        </div>
        <div class="focus-body" id="focusBody">
          <p id="overdueMessage"></p>
        </div>
      </div>
      <div class="kanban-board" id="kanbanBoard">
        <div class="kanban-column todo" data-status="todo">
          <h3><span class="column-title">To Do</span><span class="task-count" id="count-todo">0</span></h3>
          <div class="kanban-tasks" id="tasks-todo"></div>
        </div>
        <div class="kanban-column doing" data-status="doing">
          <h3><span class="column-title">Doing</span><span class="task-count" id="count-doing">0</span></h3>
          <div class="kanban-tasks" id="tasks-doing"></div>
        </div>
        <div class="kanban-column done" data-status="done">
          <h3><span class="column-title">Done</span><span class="task-count" id="count-done">0</span></h3>
          <div class="kanban-tasks" id="tasks-done"></div>
          <div class="history-controls">
            <button id="clearHistoryBtn" class="danger-button ghost-button">Clear History</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <div class="modal" id="taskModal">
    <div class="modal-content">
      <h3 id="taskModalTitle">Add Task</h3>
      <form id="taskForm">
        <label for="taskTitle">Title</label>
        <input type="text" id="taskTitle" required />

        <label for="taskDesc">Description</label>
        <textarea id="taskDesc" rows="3"></textarea>

        <label for="taskSubtasks">Subtasks</label>
        <div id="subtasksContainer">
          <input type="text" class="subtask-input" placeholder="Add subtask and press Enter" />
        </div>

        <label>Priority</label>
        <div id="priorityBoxContainer" class="priority-boxes">
          <span class="priority-box urgent" data-value="urgent">Urgent</span>
          <span class="priority-box high" data-value="high">High</span>
          <span class="priority-box medium" data-value="medium">Medium</span>
          <span class="priority-box low" data-value="low">Low</span>
        </div>
        <input type="hidden" id="taskPriority" value="low" />

        <label for="taskDueDate">Due Date</label>
        <input type="date" id="taskDueDate" />

        <label for="taskDueTime">Due Time (optional)</label>
        <input type="time" id="taskDueTime" />

        <label for="taskAssigned">Assign to (comma separated names)</label>
        <input type="text" id="taskAssigned" placeholder="e.g. Alice, Bob" />

        <div class="modal-actions">
          <button type="button" class="ghost-button" id="cancelTaskBtn">Cancel</button>
          <button type="submit">Save</button>
        </div>
      </form>
    </div>
  </div>

  <div class="modal" id="cardZoomModal">
    <div class="modal-content" id="zoomContent"></div>
  </div>

  <script>
    const STORAGE_KEYS = {
      tasks: 'ownYourPrime.tasks',
      wip: 'ownYourPrime.wipLimits',
      googleClientId: 'ownYourPrime.googleClientId',
      filters: 'ownYourPrime.filters',
      focusCollapsed: 'ownYourPrime.focusCollapsed',
      focusSnoozeUntil: 'ownYourPrime.focusSnoozeUntil'
    };

    const DEFAULT_ASSIGNEE = 'Prime Self';

    const HISTORY_STAGES = [
      { id: '30', shortLabel: '30d+', description: 'tasks completed 30 or more days ago', predicate: (task, now) => completedDaysAgo(task, now) >= 30 },
      { id: '7', shortLabel: '7d+', description: 'tasks completed 7 or more days ago', predicate: (task, now) => completedDaysAgo(task, now) >= 7 },
      { id: '1', shortLabel: 'Yesterday', description: 'tasks completed before today', predicate: (task, now) => completedDaysAgo(task, now) >= 1 },
      { id: 'all', shortLabel: 'All', description: 'all completed tasks', predicate: () => true }
    ];

    const FILTER_DEFINITIONS = {
      urgent: { predicate: (task, now) => isTaskUrgent(task) },
      overdue: { predicate: (task, now) => isTaskOverdue(task, now) },
      dueSoon: { predicate: (task, now) => isTaskDueSoon(task, now) }
    };

    const elements = {
      search: document.getElementById('taskSearch'),
      addTask: document.getElementById('addTaskBtn'),
      filterBtn: document.getElementById('filterBtn'),
      filterCount: document.getElementById('filterCount'),
      filterMenu: document.getElementById('filterMenu'),
      dataMenuBtn: document.getElementById('dataMenuBtn'),
      dataDropdown: document.getElementById('dataDropdown'),
      export: document.getElementById('exportBtn'),
      import: document.getElementById('importBtn'),
      importFile: document.getElementById('importFile'),
      driveStatus: document.getElementById('driveStatus'),
      driveMenu: document.getElementById('driveMenu'),
      driveConnect: document.getElementById('driveConnectBtn'),
      driveDisconnect: document.getElementById('driveDisconnectBtn'),
      driveSaveNow: document.getElementById('driveSaveNowBtn'),
      driveLoad: document.getElementById('driveLoadBtn'),
      clearHistory: document.getElementById('clearHistoryBtn'),
      overdueNotice: document.getElementById('overdueNotice'),
      overdueMessage: document.getElementById('overdueMessage'),
      focusSnoozeSelect: document.getElementById('focusSnoozeSelect'),
      focusToggleBtn: document.getElementById('focusToggleBtn'),
      focusBody: document.getElementById('focusBody'),
      taskModal: document.getElementById('taskModal'),
      taskForm: document.getElementById('taskForm'),
      taskModalTitle: document.getElementById('taskModalTitle'),
      cancelTask: document.getElementById('cancelTaskBtn'),
      subtasksContainer: document.getElementById('subtasksContainer'),
      priorityBoxes: document.querySelectorAll('.priority-box'),
      limits: {
        todo: document.getElementById('limit-todo'),
        doing: document.getElementById('limit-doing'),
        done: document.getElementById('limit-done')
      },
      taskContainers: {
        todo: document.getElementById('tasks-todo'),
        doing: document.getElementById('tasks-doing'),
        done: document.getElementById('tasks-done')
      },
      taskCounts: {
        todo: document.getElementById('count-todo'),
        doing: document.getElementById('count-doing'),
        done: document.getElementById('count-done')
      },
      zoomModal: document.getElementById('cardZoomModal'),
      zoomContent: document.getElementById('zoomContent')
    };

    if (elements.overdueNotice) {
      elements.overdueNotice.classList.toggle('collapsed', focusCollapsed);
      if (elements.focusToggleBtn) {
        elements.focusToggleBtn.textContent = focusCollapsed ? 'Expand' : 'Minimize';
        elements.focusToggleBtn.setAttribute('aria-expanded', focusCollapsed ? 'false' : 'true');
      }
    }

    syncFilterMenuToState();
    if (elements.filterBtn) elements.filterBtn.setAttribute('aria-expanded', 'false');
    if (elements.dataMenuBtn) elements.dataMenuBtn.setAttribute('aria-expanded', 'false');

    function saveToStorage(key, data) {
      try {
        localStorage.setItem(key, JSON.stringify(data));
      } catch (error) {
        console.warn('Storage save failed', error);
      }
    }

    function loadFromStorage(key) {
      try {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : null;
      } catch (error) {
        console.warn('Storage load failed', error);
        return null;
      }
    }

    function removeFromStorage(key) {
      try {
        localStorage.removeItem(key);
      } catch (error) {
        console.warn('Storage remove failed', error);
      }
    }

    function generateId() {
      return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str ?? '';
      return div.innerHTML;
    }

    function hashStringToColor(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i += 1) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
      }
      const hue = (hash % 360 + 360) % 360;
      return `hsl(${hue}, 70%, 52%)`;
    }

    function formatDate(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    function formatDateTime(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      const h = String(date.getHours()).padStart(2, '0');
      const mi = String(date.getMinutes()).padStart(2, '0');
      return `${y}-${m}-${d} ${h}:${mi}`;
    }

    function formatDateForDisplayFromDate(date) {
      const d = String(date.getDate()).padStart(2, '0');
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const y = date.getFullYear();
      return `${d}/${m}/${y}`;
    }

    function formatDateDisplay(dateString) {
      if (!dateString || typeof dateString !== 'string') return '';
      const [year, month, day] = dateString.split('-');
      if (!year || !month || !day) return dateString;
      return `${day}/${month}/${year}`;
    }

    function formatDateTimeDisplay(dateTimeString) {
      if (!dateTimeString || typeof dateTimeString !== 'string') return '';
      const [datePart, timePart] = dateTimeString.split(' ');
      const formattedDate = formatDateDisplay(datePart);
      return timePart ? `${formattedDate} ${timePart}` : formattedDate;
    }

    function formatDateTimeDisplayFromDate(date) {
      const formattedDate = formatDateForDisplayFromDate(date);
      const h = String(date.getHours()).padStart(2, '0');
      const mi = String(date.getMinutes()).padStart(2, '0');
      return `${formattedDate} ${h}:${mi}`;
    }

    function parseDueDateTime(task) {
      if (!task || !task.dueDate) return null;
      const dueTime = task.dueTime ? `${task.dueTime}:00` : '23:59:00';
      const parsed = new Date(`${task.dueDate}T${dueTime}`);
      if (Number.isNaN(parsed.getTime())) return null;
      return parsed;
    }

    function getDueTimestamp(task) {
      const parsed = parseDueDateTime(task);
      return parsed ? parsed.getTime() : Number.NEGATIVE_INFINITY;
    }

    function isTaskUrgent(task) {
      return task.priority === 'urgent' && task.status !== 'done';
    }

    function isTaskOverdue(task, now = new Date()) {
      if (!task || task.status === 'done') return false;
      const due = parseDueDateTime(task);
      if (!due) return false;
      return due.getTime() < now.getTime();
    }

    function isTaskDueSoon(task, now = new Date()) {
      if (!task || task.status === 'done') return false;
      const due = parseDueDateTime(task);
      if (!due) return false;
      const diff = due.getTime() - now.getTime();
      return diff >= 0 && diff <= 7 * 86400000;
    }

    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const sec = seconds % 60;
      if (hours > 0) {
        return `${hours}h ${String(minutes).padStart(2, '0')}m`;
      }
      return `${minutes}m ${String(sec).padStart(2, '0')}s`;
    }

    function normalizeTask(raw) {
      const normalized = { ...raw };
      if (!normalized.id) normalized.id = generateId();
      if (!Array.isArray(normalized.assigned)) {
        normalized.assigned = (typeof normalized.assigned === 'string' && normalized.assigned)
          ? normalized.assigned.split(',').map((name) => name.trim()).filter(Boolean)
          : [DEFAULT_ASSIGNEE];
      }
      if (!Array.isArray(normalized.subtasks)) {
        normalized.subtasks = [];
      }
      if (normalized.subtasks.length && typeof normalized.subtasks[0] === 'string') {
        normalized.subtasks = normalized.subtasks.map((title) => ({ title, done: false }));
      }
      if (!normalized.priority) normalized.priority = 'low';
      if (!normalized.status) normalized.status = 'todo';
      if (!normalized.notes) normalized.notes = '';
      if (normalized.status === 'doing' && !normalized.startedAt) {
        normalized.startedAt = Date.now();
      }
      if (normalized.status === 'done' && !normalized.completedAt) {
        normalized.completedAt = formatDateTime(new Date());
      }
      normalized.attemptCount = normalized.attemptCount ?? 0;
      normalized.timeSpent = normalized.timeSpent ?? 0;
      return normalized;
    }

    function completedDaysAgo(task, now = new Date()) {
      if (!task.completedAt) return -1;
      const completed = new Date(task.completedAt);
      const diff = now - completed;
      if (Number.isNaN(diff)) return -1;
      return Math.floor(diff / 86400000);
    }

    const savedFilters = loadFromStorage(STORAGE_KEYS.filters);
    let activeFilters = new Set(Array.isArray(savedFilters) ? savedFilters : []);
    let filterMenuOpen = false;
    let dataMenuOpen = false;
    let driveMenuOpen = false;

    let tasks = (loadFromStorage(STORAGE_KEYS.tasks) || []).map(normalizeTask);
    let wipLimits = loadFromStorage(STORAGE_KEYS.wip) || { todo: null, doing: null, done: null };
    let editingTaskId = null;
    let historyStageIndex = 0;
    let focusCollapsed = loadFromStorage(STORAGE_KEYS.focusCollapsed);
    if (typeof focusCollapsed !== 'boolean') focusCollapsed = true;
    let focusSnoozeUntil = loadFromStorage(STORAGE_KEYS.focusSnoozeUntil);
    if (typeof focusSnoozeUntil === 'string') focusSnoozeUntil = Number(focusSnoozeUntil);
    if (!Number.isFinite(focusSnoozeUntil)) focusSnoozeUntil = null;
    let driveAutosaveTimer = null;
    let driveAutosavePending = false;
    let driveSavingInFlight = false;
    let lastDriveAutosave = null;

    if (tasks.length === 0) {
      const tomorrow = formatDate(new Date(Date.now() + 86400000));
      tasks = [
        normalizeTask({
          id: generateId(),
          title: 'Blueprint the big win',
          description: 'Draft the milestones that will move the needle this week.',
          priority: 'high',
          assigned: ['Prime Self'],
          status: 'todo',
          dueDate: tomorrow,
          dueTime: '',
          attemptCount: 0,
          subtasks: []
        }),
        normalizeTask({
          id: generateId(),
          title: 'Prototype focus ritual',
          description: 'Run a 45 minute deep work sprint and document friction points.',
          priority: 'medium',
          assigned: ['Prime Self'],
          status: 'doing',
          dueDate: tomorrow,
          startedAt: Date.now(),
          subtasks: []
        }),
        normalizeTask({
          id: generateId(),
          title: 'Celebrate yesterday\'s win',
          description: 'Capture gratitude & lessons learned from yesterday\'s momentum.',
          priority: 'low',
          assigned: ['Prime Self'],
          status: 'done',
          dueDate: formatDate(new Date(Date.now() - 86400000)),
          completedAt: formatDateTime(new Date())
        })
      ];
      saveToStorage(STORAGE_KEYS.tasks, tasks);
    }

    Object.entries(wipLimits).forEach(([status, value]) => {
      const input = elements.limits[status];
      if (input) input.value = value ?? '';
    });

    function renderBoard() {
      const scrollPositions = {};
      Object.entries(elements.taskContainers).forEach(([status, container]) => {
        scrollPositions[status] = container.scrollTop;
        container.innerHTML = '';
      });

      const searchTerm = elements.search.value.trim().toLowerCase();
      const now = new Date();

      tasks
        .filter((task) => matchesSearch(task, searchTerm))
        .filter((task) => matchesActiveFilters(task, now))
        .sort(taskSorter)
        .forEach((task) => {
          const card = buildTaskCard(task, now);
          elements.taskContainers[task.status].appendChild(card);
        });

      Object.entries(elements.taskContainers).forEach(([status, container]) => {
        container.scrollTop = scrollPositions[status] ?? 0;
        elements.taskCounts[status].textContent = container.children.length;
      });

      updateFilterIndicators(now);
      updateOverdueNotice(now);
      updateHistoryButton();
    }

    function matchesSearch(task, term) {
      if (!term) return true;
      const haystack = [
        task.title,
        task.description,
        task.notes,
        ...(task.assigned || []),
        ...(task.subtasks || []).map((sub) => sub.title)
      ].join(' ').toLowerCase();
      return haystack.includes(term);
    }

    function matchesActiveFilters(task, now) {
      if (!(activeFilters instanceof Set) || activeFilters.size === 0) return true;
      for (const filterId of activeFilters) {
        const definition = FILTER_DEFINITIONS[filterId];
        if (!definition || definition.predicate(task, now)) {
          return true;
        }
      }
      return false;
    }

    function syncFilterMenuToState() {
      if (!elements.filterMenu) return;
      const checkboxes = elements.filterMenu.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((checkbox) => {
        checkbox.checked = activeFilters.has(checkbox.value);
      });
    }

    function updateFilterIndicators(now = new Date()) {
      if (!elements.filterBtn) return;
      const flaggedIds = new Set();
      tasks.forEach((task) => {
        if (isTaskUrgent(task) || isTaskOverdue(task, now)) {
          flaggedIds.add(task.id);
        }
      });
      const count = flaggedIds.size;
      if (elements.filterCount) {
        elements.filterCount.textContent = count;
        elements.filterCount.style.display = count > 0 ? 'inline-block' : 'none';
      }
      elements.filterBtn.classList.toggle('filter-active', activeFilters.size > 0);
      elements.filterBtn.setAttribute('aria-pressed', activeFilters.size > 0 ? 'true' : 'false');
      elements.filterBtn.title = count
        ? `${count} urgent or overdue task${count === 1 ? '' : 's'}`
        : 'Filter tasks';
      syncFilterMenuToState();
    }

    function closeFilterMenu() {
      if (!elements.filterMenu) return;
      elements.filterMenu.classList.remove('open');
      filterMenuOpen = false;
      if (elements.filterBtn) elements.filterBtn.setAttribute('aria-expanded', 'false');
    }

    function openFilterMenu() {
      if (!elements.filterMenu) return;
      elements.filterMenu.classList.add('open');
      filterMenuOpen = true;
      if (elements.filterBtn) elements.filterBtn.setAttribute('aria-expanded', 'true');
    }

    function closeDataMenu() {
      if (!elements.dataDropdown) return;
      elements.dataDropdown.classList.remove('open');
      dataMenuOpen = false;
      if (elements.dataMenuBtn) elements.dataMenuBtn.setAttribute('aria-expanded', 'false');
    }

    function openDataMenu() {
      if (!elements.dataDropdown) return;
      elements.dataDropdown.classList.add('open');
      dataMenuOpen = true;
      if (elements.dataMenuBtn) elements.dataMenuBtn.setAttribute('aria-expanded', 'true');
    }

    function closeDriveMenu() {
      if (!elements.driveMenu) return;
      elements.driveMenu.classList.remove('open');
      driveMenuOpen = false;
      updateDriveStatusLabel();
    }

    function openDriveMenu() {
      if (!elements.driveMenu) return;
      elements.driveMenu.classList.add('open');
      driveMenuOpen = true;
      updateDriveStatusLabel();
    }

    function closeAllMenus() {
      closeFilterMenu();
      closeDataMenu();
      closeDriveMenu();
    }

    function taskSorter(a, b) {
      const statusOrder = { todo: 0, doing: 1, done: 2 };
      if (statusOrder[a.status] !== statusOrder[b.status]) {
        return statusOrder[a.status] - statusOrder[b.status];
      }

      if (a.status === 'done' && b.status === 'done') {
        const aCompleted = a.completedAt ? new Date(a.completedAt).getTime() : 0;
        const bCompleted = b.completedAt ? new Date(b.completedAt).getTime() : 0;
        return bCompleted - aCompleted;
      }

      const priorityRank = { urgent: 0, high: 1, medium: 2, low: 3 };
      const aRank = priorityRank[a.priority] ?? 4;
      const bRank = priorityRank[b.priority] ?? 4;
      if (aRank !== bRank) return aRank - bRank;

      const aDue = parseDueDateTime(a);
      const bDue = parseDueDateTime(b);
      if (aDue && bDue) {
        const aTime = aDue.getTime();
        const bTime = bDue.getTime();
        if (aTime !== bTime) return bTime - aTime;
      }
      if (aDue && !bDue) return -1;
      if (bDue && !aDue) return 1;

      if (a.status === 'doing') {
        const aStart = a.startedAt || 0;
        const bStart = b.startedAt || 0;
        if (aStart && bStart && aStart !== bStart) return aStart - bStart;
      }

      return a.title.localeCompare(b.title);
    }

    function buildTaskCard(task, now = new Date()) {
      const card = document.createElement('article');
      card.className = 'kanban-card';
      card.dataset.id = task.id;
      card.dataset.priority = task.priority;
      card.setAttribute('draggable', 'true');

      const header = document.createElement('div');
      header.className = 'card-header';

      const title = document.createElement('h4');
      title.textContent = task.title;
      header.appendChild(title);

      const actions = document.createElement('div');
      actions.className = 'action-buttons';

      actions.appendChild(createIconButton('âœŽ', 'Edit task', () => openTaskEditor(task.id)));

      if (task.status === 'todo') {
        actions.appendChild(createIconButton('â–¶', 'Start task', () => moveTaskToDoing(task.id)));
        actions.appendChild(createIconButton('âœ“', 'Mark complete', () => completeTask(task.id)));
      } else if (task.status === 'doing') {
        actions.appendChild(createIconButton('âœ“', 'Mark complete', () => completeTask(task.id)));
        actions.appendChild(createIconButton('â†º', 'Send back to To Do', () => markAttempt(task.id)));
      } else if (task.status === 'done') {
        actions.appendChild(createIconButton('â†»', 'Reopen in Doing', () => reopenTask(task.id)));
      }

      actions.appendChild(createIconButton('âœ•', 'Delete task', () => deleteTask(task.id)));
      header.appendChild(actions);
      card.appendChild(header);

      if (task.description) {
        const desc = document.createElement('p');
        desc.textContent = task.description;
        card.appendChild(desc);
      }

      if (task.subtasks && task.subtasks.length) {
        const list = document.createElement('ul');
        list.className = 'subtask-list';
        task.subtasks.forEach((subtask, index) => {
          const item = document.createElement('li');
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.className = 'subtask-checkbox';
          checkbox.dataset.id = task.id;
          checkbox.dataset.index = String(index);
          checkbox.checked = Boolean(subtask.done);
          checkbox.addEventListener('change', handleSubtaskToggle);
          const span = document.createElement('span');
          span.className = `subtask-text${subtask.done ? ' done' : ''}`;
          span.textContent = subtask.title;
          label.appendChild(checkbox);
          label.appendChild(document.createTextNode(' '));
          label.appendChild(span);
          item.appendChild(label);
          list.appendChild(item);
        });
        card.appendChild(list);
      }

      if (task.status === 'doing') {
        const notesField = document.createElement('textarea');
        notesField.className = 'notes-field';
        notesField.placeholder = 'Add notes...';
        notesField.value = task.notes || '';
        notesField.addEventListener('blur', () => {
          const match = tasks.find((t) => t.id === task.id);
          if (match) {
            match.notes = notesField.value;
            persistTasks();
          }
        });
        card.appendChild(notesField);
      } else if (task.notes) {
        const notes = document.createElement('p');
        notes.className = 'task-notes';
        notes.textContent = task.notes;
        card.appendChild(notes);
      }

      const meta = document.createElement('div');
      meta.className = 'card-meta';

      if (task.dueDate) {
        const due = document.createElement('span');
        due.className = 'due-date';
        const dueLabel = formatDateDisplay(task.dueDate);
        due.textContent = `Due: ${dueLabel}${task.dueTime ? ` ${task.dueTime}` : ''}`;
        meta.appendChild(due);

        const dueDate = parseDueDateTime(task);
        if (dueDate && isTaskOverdue(task, now)) {
          card.classList.add('overdue');
          const overdueLabel = document.createElement('span');
          overdueLabel.className = 'overdue-time';
          const diffMs = now.getTime() - dueDate.getTime();
          const diffDays = Math.floor(diffMs / 86400000);
          const diffHours = Math.floor((diffMs % 86400000) / 3600000);
          const diffMinutes = Math.floor((diffMs % 3600000) / 60000);
          if (diffDays > 0) {
            overdueLabel.textContent = `Overdue by ${diffDays}d ${diffHours}h`;
          } else if (diffHours > 0) {
            overdueLabel.textContent = `Overdue by ${diffHours}h`;
          } else {
            overdueLabel.textContent = `Overdue by ${diffMinutes}m`;
          }
          meta.appendChild(overdueLabel);
        }
      }

      if (task.status === 'doing' && task.startedAt) {
        const timer = document.createElement('span');
        timer.className = 'timer';
        timer.textContent = formatOngoingTimer(task.startedAt);
        meta.appendChild(timer);
      }

      if ((task.status !== 'doing' || !task.startedAt) && task.timeSpent > 0) {
        const span = document.createElement('span');
        span.textContent = `Spent: ${formatDuration(task.timeSpent)}`;
        meta.appendChild(span);
      }

      if (task.attemptCount > 0) {
        const span = document.createElement('span');
        span.textContent = `Attempts: ${task.attemptCount}`;
        meta.appendChild(span);
      }

      if (task.status === 'done' && task.completedAt) {
        const span = document.createElement('span');
        span.textContent = `Done: ${formatDateTimeDisplay(task.completedAt)}`;
        meta.appendChild(span);
      }

      if (meta.children.length) {
        card.appendChild(meta);
      }

      const footer = document.createElement('div');
      footer.className = 'card-footer';

      const assigned = document.createElement('div');
      assigned.className = 'assigned';
      (task.assigned || [DEFAULT_ASSIGNEE]).forEach((name) => {
        const avatar = document.createElement('div');
        avatar.className = 'avatar';
        avatar.style.backgroundColor = hashStringToColor(name.trim() || DEFAULT_ASSIGNEE);
        avatar.title = name.trim() || DEFAULT_ASSIGNEE;
        avatar.textContent = (name.trim() || DEFAULT_ASSIGNEE).charAt(0).toUpperCase();
        assigned.appendChild(avatar);
      });
      footer.appendChild(assigned);

      const priority = document.createElement('span');
      priority.className = 'priority-label';
      priority.style.backgroundColor = getPriorityColor(task.priority);
      priority.textContent = task.priority.toUpperCase();
      footer.appendChild(priority);

      card.appendChild(footer);

      card.addEventListener('dblclick', () => openZoom(task.id));
      card.addEventListener('dragstart', (event) => {
        event.dataTransfer.setData('text/plain', task.id);
      });

      return card;
    }

    function getPriorityColor(priority) {
      switch (priority) {
        case 'urgent': return 'var(--priority-urgent)';
        case 'high': return 'var(--priority-high)';
        case 'medium': return 'var(--priority-medium)';
        default: return 'var(--priority-low)';
      }
    }

    function createIconButton(icon, title, handler) {
      const button = document.createElement('button');
      button.type = 'button';
      button.textContent = icon;
      button.title = title;
      button.addEventListener('click', (event) => {
        event.stopPropagation();
        handler();
      });
      return button;
    }

    function formatOngoingTimer(startedAt) {
      const diff = Date.now() - startedAt;
      const hrs = Math.floor(diff / 3600000);
      const mins = Math.floor((diff % 3600000) / 60000);
      const secs = Math.floor((diff % 60000) / 1000);
      return `${hrs > 0 ? `${hrs}h ` : ''}${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function handleSubtaskToggle(event) {
      const { id, index } = event.target.dataset;
      const task = tasks.find((t) => t.id === id);
      if (!task || !task.subtasks[index]) return;
      task.subtasks[index].done = event.target.checked;
      persistTasks();
      renderBoard();
    }

    function moveTaskToDoing(taskId) {
      const task = tasks.find((t) => t.id === taskId);
      if (!task) return;
      if (!canEnterDoing(taskId)) return;
      task.status = 'doing';
      task.startedAt = Date.now();
      persistTasks();
      renderBoard();
    }

    function completeTask(taskId) {
      const task = tasks.find((t) => t.id === taskId);
      if (!task) return;
      if (task.startedAt) {
        task.timeSpent = (task.timeSpent || 0) + (Date.now() - task.startedAt);
        delete task.startedAt;
      }
      task.status = 'done';
      task.completedAt = formatDateTime(new Date());
      persistTasks();
      renderBoard();
    }

    function markAttempt(taskId) {
      const task = tasks.find((t) => t.id === taskId);
      if (!task) return;
      const delta = task.startedAt ? Date.now() - task.startedAt : 0;
      task.timeSpent = (task.timeSpent || 0) + delta;
      delete task.startedAt;
      task.attemptCount = (task.attemptCount || 0) + 1;
      task.status = 'todo';
      persistTasks();
      renderBoard();
    }

    function reopenTask(taskId) {
      const task = tasks.find((t) => t.id === taskId);
      if (!task) return;
      if (!canEnterDoing(taskId)) return;
      task.status = 'doing';
      task.startedAt = Date.now();
      persistTasks();
      renderBoard();
    }

    function deleteTask(taskId) {
      const task = tasks.find((t) => t.id === taskId);
      if (!task) return;
      if (!confirm(`Delete "${task.title}"? This cannot be undone.`)) return;
      tasks = tasks.filter((t) => t.id !== taskId);
      persistTasks();
      renderBoard();
    }

    function openTaskEditor(taskId) {
      editingTaskId = taskId;
      const task = tasks.find((t) => t.id === taskId);
      if (!task) return;
      elements.taskModalTitle.textContent = 'Edit Task';
      document.getElementById('taskTitle').value = task.title;
      document.getElementById('taskDesc').value = task.description || '';
      document.getElementById('taskDueDate').value = task.dueDate || '';
      document.getElementById('taskDueTime').value = task.dueTime || '';
      document.getElementById('taskAssigned').value = task.assigned.join(', ');
      setPrioritySelection(task.priority);
      rebuildSubtasksInModal(task.subtasks || []);
      elements.taskModal.style.display = 'flex';
    }

    function rebuildSubtasksInModal(subtasks) {
      const container = elements.subtasksContainer;
      Array.from(container.children).forEach((child) => {
        if (!child.classList.contains('subtask-input')) child.remove();
      });
      subtasks.forEach((subtask) => {
        const wrapper = document.createElement('div');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = Boolean(subtask.done);
        const label = document.createElement('label');
        label.textContent = subtask.title;
        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.insertBefore(wrapper, container.querySelector('.subtask-input'));
      });
    }

    function canEnterDoing(taskId) {
      const limit = wipLimits.doing;
      if (limit === null || limit === undefined || limit === '') return true;
      const targetLimit = Number(limit);
      if (Number.isNaN(targetLimit) || targetLimit < 0) return true;
      const currentDoing = tasks.filter((t) => t.status === 'doing' && t.id !== taskId).length;
      if (currentDoing >= targetLimit) {
        alert(`Cannot move to DOING: WIP limit is ${targetLimit}.`);
        return false;
      }
      return true;
    }

    function persistTasks() {
      saveToStorage(STORAGE_KEYS.tasks, tasks);
      scheduleDriveAutosave();
    }

    function persistWipLimits() {
      saveToStorage(STORAGE_KEYS.wip, wipLimits);
      scheduleDriveAutosave();
    }

    function persistFilters() {
      saveToStorage(STORAGE_KEYS.filters, Array.from(activeFilters));
      updateFilterIndicators();
    }

    function updateOverdueNotice(now = new Date()) {
      if (!elements.overdueNotice) return;
      if (focusSnoozeUntil && now.getTime() >= focusSnoozeUntil) {
        focusSnoozeUntil = null;
        removeFromStorage(STORAGE_KEYS.focusSnoozeUntil);
      }
      if (focusSnoozeUntil && now.getTime() < focusSnoozeUntil) {
        elements.overdueNotice.style.display = 'none';
        if (elements.overdueMessage) elements.overdueMessage.textContent = '';
        return;
      }
      const overdueTasks = tasks.filter((task) => isTaskOverdue(task, now));
      if (overdueTasks.length > 0) {
        if (elements.overdueMessage) {
          elements.overdueMessage.textContent = `${overdueTasks.length} task${overdueTasks.length === 1 ? '' : 's'} overdue and incomplete.`;
        }
        elements.overdueNotice.style.display = 'block';
        elements.overdueNotice.classList.toggle('collapsed', focusCollapsed);
        if (elements.focusToggleBtn) {
          elements.focusToggleBtn.textContent = focusCollapsed ? 'Expand' : 'Minimize';
          elements.focusToggleBtn.setAttribute('aria-expanded', focusCollapsed ? 'false' : 'true');
        }
      } else {
        elements.overdueNotice.style.display = 'none';
        if (elements.overdueMessage) elements.overdueMessage.textContent = '';
      }
    }

    function handleFocusToggle() {
      focusCollapsed = !focusCollapsed;
      saveToStorage(STORAGE_KEYS.focusCollapsed, focusCollapsed);
      updateOverdueNotice();
    }

    function handleFocusSnoozeSelection(event) {
      const { value } = event.target;
      if (!value) return;
      if (value === 'clear') {
        focusSnoozeUntil = null;
        removeFromStorage(STORAGE_KEYS.focusSnoozeUntil);
        updateOverdueNotice();
        event.target.value = '';
        return;
      }

      let minutes = value === 'custom' ? null : Number(value);
      if (value === 'custom') {
        const input = prompt('Enter snooze duration in minutes:', '30');
        const parsed = Number(input);
        if (!input || !Number.isFinite(parsed) || parsed <= 0) {
          event.target.value = '';
          return;
        }
        minutes = parsed;
      }

      if (!Number.isFinite(minutes) || minutes <= 0) {
        event.target.value = '';
        return;
      }

      focusSnoozeUntil = Date.now() + minutes * 60000;
      saveToStorage(STORAGE_KEYS.focusSnoozeUntil, focusSnoozeUntil);
      updateOverdueNotice();
      event.target.value = '';
    }

    function updateTimersLive() {
      tasks.forEach((task) => {
        if (task.status === 'doing' && task.startedAt) {
          const card = document.querySelector(`.kanban-card[data-id="${task.id}"] .timer`);
          if (card) card.textContent = formatOngoingTimer(task.startedAt);
        }
      });
    }

    function updateHistoryButton() {
      if (!elements.clearHistory) return;
      const doneTasks = tasks.filter((task) => task.status === 'done');
      elements.clearHistory.disabled = doneTasks.length === 0;
      if (doneTasks.length === 0) {
        historyStageIndex = 0;
      }
      const stage = HISTORY_STAGES[Math.min(historyStageIndex, HISTORY_STAGES.length - 1)];
      elements.clearHistory.textContent = `Clear History (${stage.shortLabel})`;
      elements.clearHistory.title = `Next: remove ${stage.description}. Confirmation required.`;
    }

    function clearHistory() {
      const stage = HISTORY_STAGES[Math.min(historyStageIndex, HISTORY_STAGES.length - 1)];
      if (!stage) return;
      const doneTasks = tasks.filter((task) => task.status === 'done');
      if (doneTasks.length === 0) {
        alert('No completed tasks to clear.');
        historyStageIndex = 0;
        updateHistoryButton();
        return;
      }
      const message = `Remove ${stage.description}?`;
      if (!confirm(`${message}\n\nThis action cannot be undone. Please double-check before confirming.`)) return;
      const now = new Date();
      const beforeCount = tasks.length;
      tasks = tasks.filter((task) => {
        if (task.status !== 'done') return true;
        return !stage.predicate(task, now);
      });
      const removedCount = beforeCount - tasks.length;
      if (removedCount === 0) {
        alert('No tasks matched this stage. Advancing to the next threshold.');
      }
      historyStageIndex = Math.min(historyStageIndex + 1, HISTORY_STAGES.length - 1);
      persistTasks();
      renderBoard();
    }

    function resetTaskModal() {
      editingTaskId = null;
      elements.taskModalTitle.textContent = 'Add Task';
      elements.taskForm.reset();
      const tomorrow = new Date(Date.now() + 86400000);
      document.getElementById('taskDueDate').value = formatDate(tomorrow);
      document.getElementById('taskAssigned').value = DEFAULT_ASSIGNEE;
      document.getElementById('taskDueTime').value = '';
      setPrioritySelection('low');
      rebuildSubtasksInModal([]);
    }

    function closeTaskModal() {
      elements.taskModal.style.display = 'none';
      resetTaskModal();
    }

    function setPrioritySelection(priority) {
      document.getElementById('taskPriority').value = priority;
      elements.priorityBoxes.forEach((box) => {
        box.classList.toggle('selected', box.dataset.value === priority);
      });
    }

    function handleTaskFormSubmit(event) {
      event.preventDefault();
      const title = document.getElementById('taskTitle').value.trim();
      const description = document.getElementById('taskDesc').value.trim();
      const priority = document.getElementById('taskPriority').value;
      const dueDateValue = document.getElementById('taskDueDate').value;
      const dueTimeValue = document.getElementById('taskDueTime').value;
      const assignedRaw = document.getElementById('taskAssigned').value;
      let assigned = assignedRaw.split(',').map((name) => name.trim()).filter(Boolean);
      if (assigned.length === 0) assigned = [DEFAULT_ASSIGNEE];
      const subtasks = Array.from(elements.subtasksContainer.children)
        .filter((node) => !node.classList.contains('subtask-input'))
        .map((node) => {
          const label = node.querySelector('label');
          if (!label) return null;
          const checkbox = node.querySelector('input[type="checkbox"]');
          return {
            title: label.textContent.trim(),
            done: checkbox ? checkbox.checked : false
          };
        })
        .filter(Boolean);

      if (!title) {
        alert('Title is required.');
        return;
      }

      if (editingTaskId) {
        const task = tasks.find((t) => t.id === editingTaskId);
        if (task) {
          task.title = title;
          task.description = description;
          task.priority = priority;
          task.assigned = assigned;
          task.dueDate = dueDateValue || '';
          task.dueTime = dueTimeValue || '';
          task.subtasks = subtasks;
        }
      } else {
        tasks.push(normalizeTask({
          id: generateId(),
          title,
          description,
          priority,
          assigned,
          status: 'todo',
          dueDate: dueDateValue || formatDate(new Date(Date.now() + 86400000)),
          dueTime: dueTimeValue || '',
          subtasks,
          attemptCount: 0,
          timeSpent: 0
        }));
      }

      persistTasks();
      closeTaskModal();
      renderBoard();
    }

    function handleSubtaskInputKeyPress(event) {
      if (!event.target.classList.contains('subtask-input')) return;
      if (event.key !== 'Enter') return;
      event.preventDefault();
      const value = event.target.value.trim();
      if (!value) return;
      const wrapper = document.createElement('div');
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = false;
      const label = document.createElement('label');
      label.textContent = value;
      wrapper.appendChild(checkbox);
      wrapper.appendChild(label);
      elements.subtasksContainer.insertBefore(wrapper, event.target);
      event.target.value = '';
    }

    function attachDropHandlers(element, status) {
      element.addEventListener('dragover', (event) => {
        event.preventDefault();
      });
      element.addEventListener('drop', (event) => {
        event.preventDefault();
        const taskId = event.dataTransfer.getData('text/plain');
        const task = tasks.find((t) => t.id === taskId);
        if (!task || task.status === status) return;
        if (status === 'doing' && !canEnterDoing(taskId)) return;
        if (task.status === 'doing' && status !== 'doing' && task.startedAt) {
          task.timeSpent = (task.timeSpent || 0) + (Date.now() - task.startedAt);
          delete task.startedAt;
        }
        if (status === 'doing') {
          task.startedAt = Date.now();
        } else {
          delete task.startedAt;
        }
        task.status = status;
        persistTasks();
        renderBoard();
      });
    }

    function showZoomModal(task) {
      const modal = elements.zoomModal;
      const content = elements.zoomContent;
      let html = `<div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">` +
        `<h3 style="margin:0;">${escapeHtml(task.title)}</h3>` +
        `<button id="closeZoomBtn" class="ghost-button" style="padding:6px 10px;">&times;</button>` +
        `</div>`;
      if (task.description) {
        html += `<p style="margin-top:8px;color:var(--color-muted);">${escapeHtml(task.description)}</p>`;
      }
      if (task.subtasks && task.subtasks.length) {
        html += '<ul style="margin-top:10px;list-style:none;padding-left:0;display:flex;flex-direction:column;gap:6px;">';
        task.subtasks.forEach((sub) => {
          const checked = sub.done ? 'checked' : '';
          const style = sub.done ? 'text-decoration:line-through;color:var(--color-muted);' : '';
          html += `<li><label><input type="checkbox" disabled ${checked}/> <span style="${style}">${escapeHtml(sub.title)}</span></label></li>`;
        });
        html += '</ul>';
      }
      if (task.notes) {
        html += `<p style="margin-top:10px;font-style:italic;color:var(--color-muted);">Notes: ${escapeHtml(task.notes)}</p>`;
      }
      html += '<div style="margin-top:12px;font-size:0.85rem;color:var(--color-muted);display:flex;flex-direction:column;gap:4px;">';
      if (task.dueDate) {
        const dueLabel = escapeHtml(formatDateDisplay(task.dueDate));
        html += `<span><strong>Due:</strong> ${dueLabel}${task.dueTime ? ` ${escapeHtml(task.dueTime)}` : ''}</span>`;
      }
      html += `<span><strong>Priority:</strong> ${escapeHtml(task.priority)}</span>`;
      if (task.timeSpent) {
        html += `<span><strong>Time spent:</strong> ${escapeHtml(formatDuration(task.timeSpent))}</span>`;
      }
      if (task.attemptCount) {
        html += `<span><strong>Attempts:</strong> ${task.attemptCount}</span>`;
      }
      if (task.completedAt) {
        html += `<span><strong>Completed:</strong> ${escapeHtml(formatDateTimeDisplay(task.completedAt))}</span>`;
      }
      html += '</div>';

      html += '<div class="zoom-actions">';
      if (task.status === 'todo') {
        html += `<button class="ghost-button" data-action="start" data-id="${task.id}">Start</button>`;
        html += `<button class="ghost-button" data-action="complete" data-id="${task.id}">Complete</button>`;
      } else if (task.status === 'doing') {
        html += `<button class="ghost-button" data-action="complete" data-id="${task.id}">Complete</button>`;
        html += `<button class="ghost-button" data-action="attempt" data-id="${task.id}">Mark Incomplete</button>`;
      } else if (task.status === 'done') {
        html += `<button class="ghost-button" data-action="reopen" data-id="${task.id}">Reopen</button>`;
      }
      html += `<button class="ghost-button" data-action="edit" data-id="${task.id}">Edit</button>`;
      html += `<button class="danger-button" data-action="delete" data-id="${task.id}">Delete</button>`;
      html += '</div>';

      content.innerHTML = html;
      modal.style.display = 'flex';

      content.querySelectorAll('button[data-action]').forEach((btn) => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          const id = btn.dataset.id;
          switch (action) {
            case 'start': moveTaskToDoing(id); break;
            case 'complete': completeTask(id); break;
            case 'attempt': markAttempt(id); break;
            case 'reopen': reopenTask(id); break;
            case 'edit': openTaskEditor(id); break;
            case 'delete': deleteTask(id); break;
            default: break;
          }
          modal.style.display = 'none';
        });
      });

      const closeBtn = document.getElementById('closeZoomBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
      modal.addEventListener('click', (event) => {
        if (event.target === modal) modal.style.display = 'none';
      }, { once: true });
    }

    function openZoom(taskId) {
      const task = tasks.find((t) => t.id === taskId);
      if (!task) return;
      showZoomModal(task);
    }

    const currentDateTimeEl = document.getElementById('currentDateTime');
    function updateCurrentDateTime() {
      const now = new Date();
      const formatted = `${formatDateForDisplayFromDate(now)} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
      currentDateTimeEl.textContent = formatted;
    }

    function exportTasksToFile() {
      const payload = {
        exportedAt: new Date().toISOString(),
        version: 1,
        wipLimits,
        tasks
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `own-your-prime-${Date.now()}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function importTasksFromFile(file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const parsed = JSON.parse(event.target.result);
          if (!parsed || !Array.isArray(parsed.tasks)) throw new Error('Invalid file structure.');
          tasks = parsed.tasks.map(normalizeTask);
          wipLimits = parsed.wipLimits || wipLimits;
          Object.entries(wipLimits).forEach(([status, value]) => {
            const input = elements.limits[status];
            if (input) input.value = value ?? '';
          });
          persistTasks();
          persistWipLimits();
          renderBoard();
          alert('Kanban data imported successfully.');
        } catch (error) {
          console.error(error);
          alert('Failed to import file. Ensure it is a valid Own Your Prime export.');
        }
      };
      reader.onerror = () => {
        alert('Unable to read the selected file.');
      };
      reader.readAsText(file);
    }

    const GOOGLE_SCOPE = 'https://www.googleapis.com/auth/drive.file';
    const DRIVE_FILE_PREFIX = 'own-your-prime-kanban';
    const DRIVE_MIME_TYPE = 'application/json';
    const DRIVE_AUTOSAVE_DELAY = 8000;

    let googleClientId = loadFromStorage(STORAGE_KEYS.googleClientId) || '';
    let tokenClient = null;
    let gapiReady = false;
    let gisReady = false;

    function isDriveConnected() {
      return !!(window.gapi && gapi.client && gapi.client.getToken && gapi.client.getToken());
    }

    function updateDriveStatusLabel() {
      if (!elements.driveStatus) return;
      const hasToken = isDriveConnected();
      const ready = Boolean(googleClientId) && gapiReady && gisReady;
      let label = 'Google Drive: Offline';
      if (hasToken && driveSavingInFlight) {
        label = 'Google Drive: Savingâ€¦';
      } else if (hasToken && driveAutosavePending) {
        label = 'Google Drive: Autosave queued';
      } else if (hasToken) {
        label = 'Google Drive: Autosave on';
      } else if (ready) {
        label = 'Google Drive: Ready';
      }
      elements.driveStatus.textContent = label;
      elements.driveStatus.setAttribute('aria-expanded', driveMenuOpen ? 'true' : 'false');

      const tooltip = [];
      if (!googleClientId) {
        tooltip.push('Provide your OAuth client ID to enable Drive sync.');
      }
      if (hasToken && lastDriveAutosave) {
        tooltip.push(`Last autosave ${formatDateTimeDisplayFromDate(new Date(lastDriveAutosave))}`);
      }
      elements.driveStatus.title = tooltip.join('\n') || 'Connect Google Drive for automatic backups.';

      elements.driveConnect.disabled = !ready || hasToken;
      elements.driveDisconnect.disabled = !hasToken || driveSavingInFlight;
      elements.driveSaveNow.disabled = !hasToken || driveSavingInFlight;
      elements.driveLoad.disabled = !hasToken || driveSavingInFlight;
    }

    function updateDriveUi() {
      updateDriveStatusLabel();
    }

    function promptForClientId() {
      const input = prompt('Enter your Google OAuth Client ID (ending with .apps.googleusercontent.com):', googleClientId || '');
      if (!input) return false;
      googleClientId = input.trim();
      saveToStorage(STORAGE_KEYS.googleClientId, googleClientId);
      initializeTokenClient();
      updateDriveUi();
      return true;
    }

    function initializeTokenClient() {
      if (!gisReady || !googleClientId) return;
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: googleClientId,
        scope: GOOGLE_SCOPE,
        callback: (response) => {
          if (response.error) {
            console.error(response);
            alert('Google authorization failed.');
            return;
          }
          updateDriveUi();
        }
      });
    }

    async function ensureDriveReady() {
      if (!gapiReady || !gisReady) {
        alert('Google APIs are still loading. Please wait a moment.');
        return false;
      }
      if (!googleClientId) {
        return promptForClientId();
      }
      if (!tokenClient) {
        initializeTokenClient();
      }
      return true;
    }

    async function ensureAuthorized() {
      if (!await ensureDriveReady()) return false;
      const token = gapi.client.getToken();
      if (token) {
        updateDriveUi();
        return true;
      }
      return new Promise((resolve) => {
        tokenClient.callback = (response) => {
          if (response.error) {
            console.error(response);
            alert('Authorization failed.');
            resolve(false);
            return;
          }
          updateDriveUi();
          resolve(true);
        };
        tokenClient.requestAccessToken({ prompt: 'consent' });
      });
    }

    function cancelScheduledAutosave() {
      if (driveAutosaveTimer) {
        clearTimeout(driveAutosaveTimer);
        driveAutosaveTimer = null;
      }
      driveAutosavePending = false;
    }

    function scheduleDriveAutosave() {
      if (!isDriveConnected()) return;
      driveAutosavePending = true;
      if (driveAutosaveTimer) clearTimeout(driveAutosaveTimer);
      driveAutosaveTimer = setTimeout(() => {
        saveToDrive({ autosave: true }).catch((error) => console.error('Autosave failed', error));
      }, DRIVE_AUTOSAVE_DELAY);
      updateDriveStatusLabel();
    }

    function buildDrivePayload() {
      return JSON.stringify({
        exportedAt: new Date().toISOString(),
        version: 1,
        wipLimits,
        tasks
      }, null, 2);
    }

    async function saveToDrive({ autosave = false } = {}) {
      if (autosave) {
        if (!isDriveConnected()) {
          cancelScheduledAutosave();
          updateDriveStatusLabel();
          return;
        }
      } else if (!await ensureAuthorized()) {
        return;
      }

      cancelScheduledAutosave();
      driveSavingInFlight = true;
      updateDriveStatusLabel();

      const payload = buildDrivePayload();
      const timestamp = new Date();
      const stamp = `${timestamp.getFullYear()}${String(timestamp.getMonth() + 1).padStart(2, '0')}${String(timestamp.getDate()).padStart(2, '0')}-${String(timestamp.getHours()).padStart(2, '0')}${String(timestamp.getMinutes()).padStart(2, '0')}${String(timestamp.getSeconds()).padStart(2, '0')}`;
      const metadata = {
        name: `${DRIVE_FILE_PREFIX}-${stamp}.json`,
        mimeType: DRIVE_MIME_TYPE
      };
      const boundary = 'own-your-prime-boundary';
      const delimiter = `\r\n--${boundary}\r\n`;
      const closeDelimiter = `\r\n--${boundary}--`;
      const body = delimiter
        + 'Content-Type: application/json; charset=UTF-8\r\n\r\n'
        + JSON.stringify(metadata)
        + delimiter
        + 'Content-Type: application/json\r\n\r\n'
        + payload
        + closeDelimiter;

      try {
        await gapi.client.request({
          path: '/upload/drive/v3/files',
          method: 'POST',
          params: { uploadType: 'multipart' },
          headers: { 'Content-Type': `multipart/related; boundary=${boundary}` },
          body
        });
        lastDriveAutosave = timestamp.getTime();
        if (!autosave) {
          alert('Board snapshot saved to Google Drive.');
        }
      } catch (error) {
        console.error(error);
        if (!autosave) {
          alert('Failed to save to Google Drive. Check console for details.');
        }
      } finally {
        driveSavingInFlight = false;
        driveAutosavePending = false;
        driveAutosaveTimer = null;
        updateDriveStatusLabel();
      }
    }

    async function loadFromDrive() {
      if (!await ensureAuthorized()) return;
      try {
        const list = await gapi.client.drive.files.list({
          q: `name contains '${DRIVE_FILE_PREFIX}' and trashed=false`,
          orderBy: 'createdTime desc',
          pageSize: 1,
          fields: 'files(id, name)',
          spaces: 'drive'
        });
        const file = list.result.files?.[0];
        if (!file) {
          alert('No Own Your Prime backups found on Drive yet.');
          return;
        }
        const response = await gapi.client.drive.files.get({
          fileId: file.id,
          alt: 'media'
        });
        const data = response.body ? JSON.parse(response.body) : response.result;
        if (!data || !Array.isArray(data.tasks)) {
          throw new Error('Invalid file structure.');
        }
        tasks = data.tasks.map(normalizeTask);
        wipLimits = data.wipLimits || wipLimits;
        Object.entries(wipLimits).forEach(([status, value]) => {
          const input = elements.limits[status];
          if (input) input.value = value ?? '';
        });
        persistTasks();
        persistWipLimits();
        renderBoard();
        alert('Board loaded from Google Drive.');
      } catch (error) {
        console.error(error);
        alert('Failed to load from Google Drive.');
      }
    }

    async function signInToDrive() {
      if (!await ensureDriveReady()) return;
      if (isDriveConnected()) {
        updateDriveUi();
        return;
      }
      tokenClient.callback = (response) => {
        if (response.error) {
          console.error(response);
          alert('Authorization failed.');
          return;
        }
        updateDriveUi();
      };
      tokenClient.requestAccessToken({ prompt: 'consent' });
    }

    function signOutOfDrive() {
      const token = gapi.client.getToken && gapi.client.getToken();
      if (token) {
        google.accounts.oauth2.revoke(token.access_token, () => {
          gapi.client.setToken('');
          cancelScheduledAutosave();
          driveSavingInFlight = false;
          driveAutosavePending = false;
          driveAutosaveTimer = null;
          lastDriveAutosave = null;
          updateDriveUi();
        });
      }
    }

    function setupGoogleApis() {
      window.handleGapiLoad = () => {
        try {
          gapi.load('client', async () => {
            try {
              await gapi.client.init({
                discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
              });
              gapiReady = true;
              updateDriveUi();
            } catch (error) {
              console.error('GAPI init failed', error);
            }
          });
        } catch (error) {
          console.error('GAPI load failed', error);
        }
      };

      window.handleGisLoad = () => {
        gisReady = true;
        if (googleClientId) {
          initializeTokenClient();
        }
        updateDriveUi();
      };
    }

    function setupEventListeners() {
      elements.search.addEventListener('input', renderBoard);
      elements.addTask.addEventListener('click', () => {
        resetTaskModal();
        elements.taskModal.style.display = 'flex';
      });
      elements.cancelTask.addEventListener('click', closeTaskModal);
      elements.taskModal.addEventListener('click', (event) => {
        if (event.target === elements.taskModal) closeTaskModal();
      });
      elements.taskForm.addEventListener('submit', handleTaskFormSubmit);
      elements.subtasksContainer.addEventListener('keypress', handleSubtaskInputKeyPress);
      elements.priorityBoxes.forEach((box) => {
        box.addEventListener('click', () => {
          setPrioritySelection(box.dataset.value);
        });
      });
      Object.entries(elements.limits).forEach(([status, input]) => {
        if (!input) return;
        input.addEventListener('change', () => {
          const value = input.value;
          wipLimits[status] = value === '' ? null : Number(value);
          persistWipLimits();
        });
      });

      if (elements.filterBtn) {
        elements.filterBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          const willOpen = !filterMenuOpen;
          closeAllMenus();
          if (willOpen) openFilterMenu();
        });
      }

      if (elements.filterMenu) {
        elements.filterMenu.addEventListener('click', (event) => event.stopPropagation());
        elements.filterMenu.querySelectorAll('input[type="checkbox"]').forEach((checkbox) => {
          checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
              activeFilters.add(checkbox.value);
            } else {
              activeFilters.delete(checkbox.value);
            }
            persistFilters();
            renderBoard();
          });
        });
        const clearFiltersBtn = elements.filterMenu.querySelector('#clearFiltersBtn');
        if (clearFiltersBtn) {
          clearFiltersBtn.addEventListener('click', () => {
            activeFilters = new Set();
            persistFilters();
            closeFilterMenu();
            renderBoard();
          });
        }
      }

      if (elements.dataMenuBtn) {
        elements.dataMenuBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          const willOpen = !dataMenuOpen;
          closeAllMenus();
          if (willOpen) openDataMenu();
        });
      }

      if (elements.dataDropdown) {
        elements.dataDropdown.addEventListener('click', (event) => event.stopPropagation());
      }

      elements.export.addEventListener('click', () => {
        closeDataMenu();
        exportTasksToFile();
      });
      elements.import.addEventListener('click', () => {
        closeDataMenu();
        elements.importFile.click();
      });
      elements.importFile.addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (file) importTasksFromFile(file);
        elements.importFile.value = '';
      });
      elements.clearHistory.addEventListener('click', clearHistory);

      if (elements.driveStatus) {
        elements.driveStatus.addEventListener('click', (event) => {
          event.stopPropagation();
          const willOpen = !driveMenuOpen;
          closeAllMenus();
          if (willOpen) openDriveMenu();
        });
      }

      if (elements.driveMenu) {
        elements.driveMenu.addEventListener('click', (event) => event.stopPropagation());
      }

      if (elements.driveConnect) {
        elements.driveConnect.addEventListener('click', async () => {
          if (!googleClientId) {
            if (!promptForClientId()) return;
          }
          await signInToDrive();
          closeDriveMenu();
        });
      }

      if (elements.driveDisconnect) {
        elements.driveDisconnect.addEventListener('click', () => {
          signOutOfDrive();
          closeDriveMenu();
        });
      }

      if (elements.driveSaveNow) {
        elements.driveSaveNow.addEventListener('click', async () => {
          await saveToDrive();
          closeDriveMenu();
        });
      }

      if (elements.driveLoad) {
        elements.driveLoad.addEventListener('click', async () => {
          await loadFromDrive();
          closeDriveMenu();
        });
      }

      if (elements.focusToggleBtn) {
        elements.focusToggleBtn.addEventListener('click', handleFocusToggle);
      }

      if (elements.focusSnoozeSelect) {
        elements.focusSnoozeSelect.addEventListener('change', handleFocusSnoozeSelection);
      }

      document.addEventListener('click', closeAllMenus);

      elements.zoomModal.addEventListener('click', (event) => {
        if (event.target === elements.zoomModal) {
          elements.zoomModal.style.display = 'none';
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeAllMenus();
          if (elements.taskModal.style.display === 'flex') closeTaskModal();
          if (elements.zoomModal.style.display === 'flex') elements.zoomModal.style.display = 'none';
        }
      });

      document.querySelectorAll('.kanban-column').forEach((column) => {
        const status = column.dataset.status;
        attachDropHandlers(column, status);
        const tasksContainer = column.querySelector('.kanban-tasks');
        if (tasksContainer) attachDropHandlers(tasksContainer, status);
      });
    }

    function initializeBoard() {
      setupEventListeners();
      setupGoogleApis();
      updateDriveUi();
      renderBoard();
      updateCurrentDateTime();
      setInterval(updateCurrentDateTime, 1000);
      setInterval(updateTimersLive, 1000);
      setInterval(() => updateFilterIndicators(), 30000);
      setInterval(updateOverdueNotice, 30000);
      setInterval(() => {
        if (document.activeElement && document.activeElement.closest('.modal')) return;
        renderBoard();
      }, 60000);
    }

    initializeBoard();
  </script>
  <script src="https://apis.google.com/js/api.js" async defer onload="handleGapiLoad && handleGapiLoad()"></script>
  <script src="https://accounts.google.com/gsi/client" async defer onload="handleGisLoad && handleGisLoad()"></script>
</body>
</html>
